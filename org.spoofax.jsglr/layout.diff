Only in src/org/spoofax: JsglrGWT.gwt.xml
diff -r --exclude=.svn /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/client/JSGLREntryPoint.java src/org/spoofax/client/JSGLREntryPoint.java
86,88c86
< 		} catch (InterruptedException e) {
<       wrap(e);
<     }
---
> 		}
diff -r --exclude=.svn /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/Main.java src/org/spoofax/jsglr/Main.java
20a21
> import org.spoofax.jsglr.client.ITreeBuilder;
23a25
> import org.spoofax.jsglr.client.imploder.MemoryRecordingTreeBuilder;
38c40
< 	public static void main(String[] args) throws FileNotFoundException, IOException, InvalidParseTableException, InterruptedException {
---
> 	public static void main(String[] args) throws FileNotFoundException, IOException, InvalidParseTableException {
57a60
> 		boolean measureMemory = false;
88a92,93
> 			} else if(args[i].equals("--measure-memory")) {
> 				measureMemory = true;
106a112
> 		ITreeBuilder treeBuilder = new Asfix2TreeBuilder(); 
111c117
< 		final SGLR sglr = new SGLR(new Asfix2TreeBuilder(), pt);
---
> 		final SGLR sglr = new SGLR(treeBuilder, pt);
123c129
< 			sglr.setTreeBuilder(new NullTreeBuilder());
---
> 			treeBuilder = new NullTreeBuilder();
125c131,139
< 			sglr.setTreeBuilder(new TreeBuilder(new TermTreeFactory(new TermFactory()), true));
---
> 			treeBuilder = new TreeBuilder(new TermTreeFactory(new TermFactory()), true);
> 		
> 		MemoryRecordingTreeBuilder memory = null;
> 		if(measureMemory) {
> 			memory = new MemoryRecordingTreeBuilder(treeBuilder);
> 			sglr.setTreeBuilder(memory);
> 		} else {
> 			sglr.setTreeBuilder(treeBuilder);
> 		}
150a165,170
> 		
> 		if(measureMemory) {
> 			System.err.println("Total memory (min/max)   : " + memory.getMinTotal() + " / " + memory.getMaxTotal());
> 			System.err.println("Used memory (min/max)    : " + memory.getMinUsed() + " / " + memory.getMaxUsed());
> 			System.err.println("# of memory measurements : " + memory.getMeasureCount());
> 		}
155c175
< 			IOException, InterruptedException {
---
> 			IOException {
164c184
< 	throws FileNotFoundException, IOException, InterruptedException {
---
> 	throws FileNotFoundException, IOException {
diff -r --exclude=.svn /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/AbstractParseNode.java src/org/spoofax/jsglr/client/AbstractParseNode.java
10,15d9
< import java.util.Arrays;
< import java.util.HashMap;
< import java.util.LinkedList;
< import java.util.Map;
< import java.util.Stack;
< 
18,72d11
< public abstract class AbstractParseNode {
< 
<   public static final int PARSE_PRODUCTION_NODE = 1;
<   public static final int PARSENODE = 2;
<   public static final int AMBIGUITY = 3;
<   public static final int PREFER = 4;
<   public static final int AVOID = 5;
<   public static final int REJECT = 6;
<   public static final int CYCLE = 7;
< 
<   private final int line;
<   private final int column;
<   
<   private Map<String, Object> properties;
< 
<   public AbstractParseNode(int line, int column) {
<     this.line = line;
<     this.column = column;
<   }
< 
<   public final boolean isAmbNode() {
<     return getNodeType() == AbstractParseNode.AMBIGUITY;
<   }
< 
<   public final boolean isParseNode() {
<     switch (getNodeType()) {
<     case AbstractParseNode.PARSENODE:
<     case AbstractParseNode.REJECT:
<     case AbstractParseNode.PREFER:
<     case AbstractParseNode.AVOID:
<       return true;
<     default:
<       return false;
<     }
<   }
< 
<   public final boolean isParseRejectNode() {
<     return getNodeType() == AbstractParseNode.REJECT;
<   }
< 
<   public final boolean isParseProductionNode() {
<     return getNodeType() == AbstractParseNode.PARSE_PRODUCTION_NODE;
<   }
< 
<   public final boolean isCycle() {
<     return getNodeType() == CYCLE;
<   }
< 
<   public int getColumn() {
<     return column;
<   }
< 
<   public int getLine() {
<     return line;
<   }
74,86c13
<   public abstract void reject();
< 
<   abstract public int getLabel();
< 
<   abstract public int getNodeType();
< 
<   abstract public AbstractParseNode[] getChildren();
< 
<   protected static final int NO_HASH_CODE = 0;
< 
<   public abstract Object toTreeBottomup(BottomupTreeBuilder builder);
< 
<   public abstract Object toTreeTopdown(TopdownTreeBuilder builder);
---
> public abstract class AbstractParseNode {
88,91c15,21
<   @Override
<   public boolean equals(Object obj) {
<     if (!(obj instanceof AbstractParseNode))
<       return false;
---
>     public static final int PARSE_PRODUCTION_NODE = 1;
>     public static final int PARSENODE = 2;
>     public static final int AMBIGUITY = 3;
>     public static final int PREFER = 4;
>     public static final int AVOID = 5;
>     public static final int REJECT = 6;
>     public static final int CYCLE = 7;
93,104c23,25
<     return ((AbstractParseNode) obj).line == line && ((AbstractParseNode) obj).column == column;
<   }
< 
<   @Override
<   public int hashCode() {
<     return line * 9197 + column;
<   }
< 
<   abstract public String toStringShallow();
< 
<   @Override
<   abstract public String toString();
---
>     public final boolean isAmbNode(){
>     	return getNodeType()==AbstractParseNode.AMBIGUITY;
>     }
106,115c27,36
<   /**
<    * Returns true if this node is in a parse production chain, i.e. it is
<    * either: - a {@link ParseProductionNode}. - a ParseNode with a
<    * {@link ParseProductionNode} child and an {@link #isParseProductionChain()}
<    * child. - a ParseNode with a single {@link #isParseProductionChain()} child.
<    * 
<    * Implementations may also return true only for the topmost node of a parse
<    * production chain.
<    */
<   public abstract boolean isParseProductionChain();
---
>     public final boolean isParseNode(){
>     	switch(getNodeType()) {
>     		case AbstractParseNode.PARSENODE:
>     		case AbstractParseNode.REJECT:
>     		case AbstractParseNode.PREFER:
>     		case AbstractParseNode.AVOID: return true;
>     	default:
>     		return false;
>     	}
>     }
117,125c38,40
<   /**
<    * @return true iff this node does not contain any character data
<    */
<   public abstract boolean isEmpty();
<   
<   public abstract AbstractParseNode getLeft();
<   
<   public abstract boolean isLayout();
<   public abstract boolean isIgnoreLayout();
---
>     public final boolean isParseRejectNode(){
>     	return getNodeType()==AbstractParseNode.REJECT;
>     }
127,131c42,44
<   public int getAmbiguityCount() {
<     Stack<AbstractParseNode> nodes = new Stack<AbstractParseNode>();
<     nodes.push(this);
<     
<     int amb = 0;
---
>     public final boolean isParseProductionNode(){
>     	return getNodeType()==AbstractParseNode.PARSE_PRODUCTION_NODE;
>     }
133,138c46,47
<     while (!nodes.isEmpty()) {
<       AbstractParseNode next = nodes.pop();
<       if (next.isAmbNode())
<         amb++;
<       
<       nodes.addAll(Arrays.asList(next.getChildren()));  
---
>     public final boolean isCycle() {
>     	return getNodeType() == CYCLE;
141,142c50
<     return amb;
<   }
---
>     public abstract void reject();
144,158c52,54
<   public final static int NEWLINE_LAYOUT = 2;
<   public final static int NONEWLINE_LAYOUT = 1;
<   public final static int OTHER_LAYOUT = 0;
<   
<   /**
<    * @return NEWLINE_LAYOUT if node ends with layout that contains a newline
<    * @return NONEWLINE_LAYOUT if node only contains layout character data (also true if node is empty)
<    * @return OTHER_LAYOUT if node contains non-layout character data and does not end with layout that
<    *           contains a newline 
<    */
<   public int getLayoutStatus() {
<     if (isLayout() && hasNewline())
<         return NEWLINE_LAYOUT;
<     if (isLayout())
<       return NONEWLINE_LAYOUT;
---
>     abstract public int getNodeType();
>     abstract public AbstractParseNode[] getChildren();
>     abstract public int getLabel();
160,164c56,58
<     /*
<      * Elements of `nodes` are never descendant of a `isLayout()` node. 
<      */
<     LinkedList<AbstractParseNode> nodes = new LinkedList<AbstractParseNode>();
<     nodes.addFirst(this);
---
>     protected static final int NO_HASH_CODE = 0;
> 
>     public abstract Object toTreeBottomup(BottomupTreeBuilder builder);
166,178c60
<     while (!nodes.isEmpty()) {
<       AbstractParseNode node = nodes.pollFirst();
<       
<       if (node.isLayout()) {
<         if (node.hasNewline())
<           return NEWLINE_LAYOUT;
<       }
<       else if (node.isParseProductionNode())
<         return OTHER_LAYOUT;
<       else 
<         for (int i = 0; i < node.getChildren().length; i++)
<           nodes.addFirst(node.getChildren()[i]);
<     }
---
>     public abstract Object toTreeTopdown(TopdownTreeBuilder builder);
180,195c62,63
<     // this is not layout but also does not contain parse production nodes => treat like layout
<     return NONEWLINE_LAYOUT;
<   }
<   
<   private boolean hasNewline() {
<     LinkedList<AbstractParseNode> nodes = new LinkedList<AbstractParseNode>();
<     nodes.add(this);
<     
<     while (!nodes.isEmpty()) {
<       AbstractParseNode node = nodes.poll();
<       if (node.isParseProductionNode() && node.getLabel() == 10 || node.getLabel() == 13)
<         return true;
< 
<       for (AbstractParseNode kid : node.getChildren())
<         nodes.add(kid);
<     }
---
>     @Override
> 	abstract public boolean equals(Object obj);
197,231c65,66
<     return false;
<   }
< 
<   public AbstractParseNode getLast() {
<     AbstractParseNode n = this;
<     while (n.getChildren().length > 0)
<       for (int i = n.getChildren().length - 1; i >= 0; i--) {
<         AbstractParseNode kid = n.getChildren()[i];
<         if (kid.isEmpty() || kid.isLayout())
<           continue;
<         n = kid;
<         break;
<       }
<     return n;
<   }
<   
<   public AbstractParseNode getRight() {
<     AbstractParseNode last = getLast();
<     AbstractParseNode right = null;
<     
<     for (int i = getChildren().length - 1; i >= 0; i--) {
<       AbstractParseNode kid = getChildren()[i];
<       AbstractParseNode kidLast = kid.getLast();
<       if (!kid.isLayout() && !kid.isEmpty() && !kid.isIgnoreLayout()) {
<         if (kidLast.getLine() < last.getLine() && (right == null || kidLast.getColumn() > right.getColumn()))
<           right = kidLast;
<         AbstractParseNode kidRight = kid.getRight();
<         if (kidRight != null && 
<             kidRight.getLine() < last.getLine() &&
<             (right == null || kidRight.getColumn() > right.getColumn()))
<           right = kidRight;
<       }
<     }
<     return right;
<   }
---
>     @Override
> 	abstract public int hashCode();
233,243c68,85
<   public void setProperty(String key, Object val) {
<     if (properties == null)
<       properties = new HashMap<String, Object>();
<     properties.put(key, val);
<   }
<   
<   public Object getProperty(String key) {
<     if (properties == null)
<       return null;
<     return properties.get(key);
<   }
---
>     abstract public String toStringShallow();
>     
>     @Override
> 	abstract public String toString();
>     
>     /**
>      * Returns true if this node is in a parse production chain,
>      * i.e. it is either:
>      * - a {@link ParseProductionNode}.
>      * - a ParseNode with a {@link ParseProductionNode} child
>      *   and an {@link #isParseProductionChain()} child.
>      * - a ParseNode with a single {@link #isParseProductionChain()}
>      *   child.
>      *   
>      * Implementations may also return true only for the topmost
>      * node of a parse production chain.
>      */
>     public abstract boolean isParseProductionChain();
diff -r --exclude=.svn /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/Accept.java src/org/spoofax/jsglr/client/Accept.java
11d10
< 
diff -r --exclude=.svn /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/AmbKey.java src/org/spoofax/jsglr/client/AmbKey.java
11d10
< 
diff -r --exclude=.svn /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/AmbiguityManager.java src/org/spoofax/jsglr/client/AmbiguityManager.java
61,68d60
<     public void decreaseAmbiguityCount() {
<       ambiguitiesCount--;
<     }
< 
<     public void decreaseAmbiguityCount(int c) {
<       ambiguitiesCount -= c;
<     }
<     
Only in /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client: BacktrackPosition.java
diff -r --exclude=.svn /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/CycleParseNode.java src/org/spoofax/jsglr/client/CycleParseNode.java
5d4
< 
15d13
< 	private transient AbstractParseNode nonAmbiguousTarget = null;
18d15
< 	  super(target.getLine(), target.getColumn());
36,51c33
< 	
< 	 @Override
< 	  public Object toTreeTopdown(TopdownTreeBuilder builder) {
< 	    return builder.buildTreeCycle(this);
< 	  }
< 
< 	private AbstractParseNode getNonAmbiguousTarget() {
< 	  if (nonAmbiguousTarget != null)
< 	    return nonAmbiguousTarget;
< 	  
< 	  nonAmbiguousTarget = this.target;
<     while (target.isAmbNode())
<       nonAmbiguousTarget = target.getChildren()[0];
<     return nonAmbiguousTarget;
< 	}
< 	
---
> 
53,54c35,40
< 		if (getNonAmbiguousTarget().isParseNode())
< 			return ((ParseNode) getNonAmbiguousTarget()).getLabel();
---
> 		AbstractParseNode target = this.target;
> 		while (target.isAmbNode()) {
> 			target = target.getChildren()[0];
> 		}
> 		if (target.isParseNode())
> 			return ((ParseNode) target).getLabel();
58a45,49
> 	public Object toTreeTopdown(TopdownTreeBuilder builder) {
> 		return builder.buildTreeCycle(this);
> 	}
> 	
> 	@Override
101a93,98
> 	
> 	@Override
>     public int getLabel() {
> 		return target.getLabel();
> 	}
> 
103,127d99
<   @Override
<   public int getLabel() {
<     // TODO Auto-generated method stub
<     return 0;
<   }
< 
<   @Override
<   public boolean isEmpty() {
<     return getNonAmbiguousTarget().isEmpty();
<   }
<   
<   @Override
<   public AbstractParseNode getLeft() {
<     return target.getLeft();
<   }
<   
<   @Override
<   public boolean isLayout() {
<     return target.isLayout();
<   }
< 
<   @Override
<   public boolean isIgnoreLayout() {
<     return target.isIgnoreLayout();
<   }
diff -r --exclude=.svn /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/Disambiguator.java src/org/spoofax/jsglr/client/Disambiguator.java
20,21d19
< import java.util.Iterator;
< import java.util.LinkedList;
22a21
> import java.util.Stack;
29d27
< import org.spoofax.jsglr.client.indentation.LayoutFilter;
38d35
<   private static final boolean LAYOUT_FITERING = true;
40c37
<   private static final int FILTER_DRAW = 1;
---
> 	private static final int FILTER_DRAW = 1;
42c39
<   private static final int FILTER_LEFT_WINS = 2;
---
> 	private static final int FILTER_LEFT_WINS = 2;
44c41
<   private static final int FILTER_RIGHT_WINS = 3;
---
> 	private static final int FILTER_RIGHT_WINS = 3;
46c43
<   private boolean filterAny;
---
> 	private boolean filterAny;
48,1064c45,687
<   private boolean filterCycles;
< 
<   private boolean filterDirectPreference;
< 
<   private boolean filterPreferenceCount;
< 
<   private boolean filterInjectionCount;
< 
<   private boolean filterLongestMatch;
< 
<   private boolean filterTopSort;
< 
<   private boolean filterReject;
< 
<   private boolean filterAssociativity;
< 
<   private boolean filterPriorities;
< 
<   private boolean filterStrict;
< 
<   private boolean logStatistics;
< 
<   private boolean ambiguityIsError;
< 
<   private int ambiguityCount;
<   private int newAmbiguityCount;
< 
<   // Current parser state
< 
<   private AmbiguityManager ambiguityManager;
< 
<   private SGLR parser;
< 
<   private ParseTable parseTable;
< 
<   private ProductionAttributeReader prodReader;
< 
<   private LayoutFilter layoutFilter;
<   private int layoutFiltering;
<   
<   // private Map<AmbKey, IParseNode> resolvedTable = new HashMap<AmbKey,
<   // IParseNode>();
< 
<   /**
<    * Sets whether any filter should be applied at all (excluding the top sort
<    * filter).
<    */
<   public final void setFilterAny(boolean filterAny) {
<     this.filterAny = filterAny;
<   }
< 
<   public final void setFilterDirectPreference(boolean filterDirectPreference) {
<     this.filterDirectPreference = filterDirectPreference;
<   }
< 
<   public boolean getFilterDirectPreference() {
<     return filterDirectPreference;
<   }
< 
<   /**
<    * For preference count filtering, see
<    * {@link #setFilterPreferenceCount(boolean)}.
<    */
<   @Deprecated
<   public final void setFilterIndirectPreference(boolean filterIndirectPreference) {
<     throw new UnsupportedOperationException();
<   }
< 
<   /**
<    * For preference count filtering, see {@link #getFilterPreferenceCount()}.
<    */
<   @Deprecated
<   public boolean getFilterIndirectPreference() {
<     throw new UnsupportedOperationException();
<   }
< 
<   public final void setFilterInjectionCount(boolean filterInjectionCount) {
<     this.filterInjectionCount = filterInjectionCount;
<   }
< 
<   public boolean getFilterInjectionCount() {
<     return filterInjectionCount;
<   }
< 
<   public final void setFilterLongestMatch(boolean filterLongestMatch) {
<     this.filterLongestMatch = filterLongestMatch;
<   }
< 
<   public boolean getLongestMatch() {
<     return filterLongestMatch;
<   }
< 
<   public final void setFilterPreferenceCount(boolean filterPreferenceCount) {
<     this.filterPreferenceCount = filterPreferenceCount;
<   }
< 
<   public boolean getFilterPreferenceCount() {
<     return filterPreferenceCount;
<   }
< 
<   public final void setFilterTopSort(boolean filterTopSort) {
<     this.filterTopSort = filterTopSort;
<   }
< 
<   public boolean getFilterTopSort() {
<     return filterTopSort;
<   }
< 
<   public void setFilterCycles(boolean filterCycles) {
<     this.filterCycles = filterCycles;
<   }
< 
<   public boolean isFilterCycles() {
<     return filterCycles;
<   }
< 
<   public void setFilterAssociativity(boolean filterAssociativity) {
<     this.filterAssociativity = filterAssociativity;
<   }
< 
<   public boolean getFilterAssociativity() {
<     return filterAssociativity;
<   }
< 
<   public void setFilterPriorities(boolean filterPriorities) {
<     this.filterPriorities = filterPriorities;
<   }
< 
<   public boolean getFilterPriorities() {
<     return filterPriorities;
<   }
< 
<   /**
<    * Sets whether to enable strict filtering, triggering a FilterException when
<    * the priorities filter encounters an unfiltered ambiguity.
<    */
<   public void setFilterStrict(boolean filterStrict) {
<     this.filterStrict = filterStrict;
<   }
< 
<   public boolean getFilterStrict() {
<     return filterStrict;
<   }
< 
<   public final void setHeuristicFilters(boolean heuristicFilters) {
<     setFilterPreferenceCount(heuristicFilters);
<     setFilterInjectionCount(heuristicFilters);
<   }
< 
<   public void setFilterReject(boolean filterReject) {
<     this.filterReject = filterReject;
<   }
< 
<   public boolean getFilterReject() {
<     return filterReject;
<   }
< 
<   public void setLogStatistics(boolean logStatistics) {
<     this.logStatistics = logStatistics;
<   }
< 
<   public boolean getLogStatistics() {
<     return logStatistics;
<   }
< 
<   public void setAmbiguityIsError(boolean ambiguityIsError) {
<     this.ambiguityIsError = ambiguityIsError;
<   }
< 
<   public boolean getAmbiguityIsError() {
<     return ambiguityIsError;
<   }
< 
<   public int getAmbiguityCount() {
<     return newAmbiguityCount;
<   }
<   
<   public int getLayoutFilteringCount() {
<     return layoutFiltering;
<   }
< 
<   public int getLayoutFilterCallCount() {
<     return layoutFilter == null ? 0 : layoutFilter.getFilterCallCount();
<   }
< 
<   public final void setDefaultFilters() {
<     filterAny = true;
<     filterCycles = false; // TODO: filterCycles; enable by default
<     filterDirectPreference = true;
<     filterPreferenceCount = false;
<     filterInjectionCount = false;
<     filterLongestMatch = true;
<     filterTopSort = true;
<     filterReject = true;
<     filterAssociativity = true;
<     filterPriorities = true;
<     filterStrict = false; // TODO: disable filterStrict hack
<     logStatistics = true;
<     ambiguityIsError = false;
<   }
< 
<   public Disambiguator() {
<     setDefaultFilters();
<   }
< 
<   public Object applyFilters(SGLR parser, AbstractParseNode root, String sort,
<       int inputLength) throws SGLRException, FilterException, InterruptedException {
<     AbstractParseNode t = root;
<     if (Tools.debugging) {
<       Tools.debug("applyFilters()");
<     }
< 
<     try {
<       try {
<         if (Tools.debugging) {
<           Tools.debug("applyFilters()");
<         }
< 
<         initializeFromParser(parser);
<         t = applyTopSortFilter(sort, t);
< 
<         if (filterAny) {
<           t = applyCycleDetectFilter(t);
< 
<           // SG_FilterTree
<           ambiguityManager.resetClustersVisitedCount();
<           t = filterTree(t);
<         }
< 
<         if (t == null)
<           return null;
<       } catch (RuntimeException e) {
<         throw new FilterException(parser,
<             "Runtime exception when applying filters", e);
<       }
<       
<       newAmbiguityCount = t.getAmbiguityCount();
< 
<       return yieldTreeTop(t);
< 
<     } finally {
< //      System.out.println("  layout filter calls at parse time: " + parser.getLayoutFilterCallCount());
< //      System.out.println("  illegal layout filtered at parse time: " + parser.getLayoutFilteringCount());
< //      System.out.println("  layout filter calls at disambiguation time: " + getLayoutFilterCallCount());
< //      System.out.println("  illegal layout filtered at disambiguation time: " + getLayoutFilteringCount());
< //      System.out.println("  enforced newline skips: " + parser.getEnforcedNewlineSkips());
< //      initializeFromParser(null);
<     }
<   }
< 
<   public void initializeFromParser(SGLR parser) {
<     if (parser == null) {
<       this.parser = null;
<       parseTable = null;
<       ambiguityCount += ambiguityManager == null ? 0 : ambiguityManager.getAmbiguitiesCount();
<       ambiguityManager = null;
<       layoutFilter = null;
<     } else {
<       this.parser = parser;
<       parseTable = parser.getParseTable();
<       prodReader = new ProductionAttributeReader(parseTable.getFactory());
<       ambiguityManager = parser.getAmbiguityManager();
<       ambiguityCount = 0;
<       layoutFilter = new LayoutFilter(parseTable, false);
<       layoutFiltering = 0;
<     }
<   }
< 
<   private void logStatus() {
<     Tools.logger("Number of rejects: ", parser.getRejectCount());
<     Tools.logger("Number of reductions: ", parser.getReductionCount());
<     Tools.logger("Number of ambiguities: ",
<         ambiguityManager.getMaxNumberOfAmbiguities());
<     Tools.logger("Number of calls to Amb: ",
<         ambiguityManager.getAmbiguityCallsCount());
<     Tools.logger("Count Eagerness Comparisons: ",
<         ambiguityManager.getEagernessComparisonCount(), " / ",
<         ambiguityManager.getEagernessSucceededCount());
<     Tools.logger("Number of Injection Counts: ",
<         ambiguityManager.getInjectionCount());
<   }
< 
<   private Object yieldTree(AbstractParseNode t) {
<     parser.getTreeBuilder().reset(); // in case yieldTree is used for debugging
<     return parser.getTreeBuilder().buildTree(t);
<   }
< 
<   private Object yieldTreeTop(AbstractParseNode t) throws SGLRException {
<     int ambCount = ambiguityManager.getAmbiguitiesCount();
< 
<     if (Tools.debugging) {
<       Tools.debug("convertToATerm: ", t);
<     }
< 
<     try {
<       ambiguityCount += ambiguityManager.getAmbiguitiesCount();
<       ambiguityManager.resetAmbiguityCount();
<       final Object r = yieldTree(t);
< 
<       if (logStatistics)
<         logStatus();
< 
<       if (Tools.debugging) {
<         Tools.debug("yield: ", r);
<       }
< 
<       if (ambiguityIsError && ambCount > 0) {
<         throw new SGLRException(parser, "Ambiguities found");
<       } else {
<         return parser.getTreeBuilder().buildTreeTop(r, ambCount);
<       }
<     } finally {
<       parser.getTreeBuilder().reset();
<     }
<   }
< 
<   private AbstractParseNode applyCycleDetectFilter(AbstractParseNode t)
<       throws FilterException {
< 
<     if (Tools.debugging) {
<       Tools.debug("applyCycleDetectFilter() - ", t);
<     }
< 
<     if (filterCycles) {
<       if (ambiguityManager.getMaxNumberOfAmbiguities() > 0) {
<         if (isCyclicTerm(t)) {
<           throw new FilterException(parser, "Term is cyclic");
<         }
<       }
<     }
< 
<     return t;
<   }
< 
<   private IStrategoTerm getProduction(AbstractParseNode t) {
<     if (t.isParseNode()) {
<       return parseTable.getProduction(((ParseNode) t).getLabel());
<     } else {
<       return parseTable.getProduction(((ParseProductionNode) t).getLabel());
<     }
<   }
< 
<   private AbstractParseNode applyTopSortFilter(String sort, AbstractParseNode t)
<       throws SGLRException {
< 
<     if (Tools.debugging) {
<       Tools.debug("applyTopSortFilter() - ", t);
<     }
< 
<     if (sort != null && filterTopSort) {
<       t = selectOnTopSort(t, sort);
<       if (t == null) {
<         throw new StartSymbolException(parser,
<             "Desired start symbol not found: " + sort);
<       }
<     }
< 
<     return t;
<   }
< 
<   private boolean matchProdOnTopSort(IStrategoTerm prod, String sort)
<       throws FilterException {
<     assert sort != null;
<     /*
<      * sort = sort.replaceAll("\"", ""); return
<      * prod.match("prod([cf(opt(layout)),cf(sort(\"" + sort +
<      * "\")),cf(opt(layout))], sort(\"<START>\"),no-attrs)") != null ||
<      * prod.match("prod([cf(sort(\"" + sort +
<      * "\"))], sort(\"<START>\"),no-attrs)") != null ||
<      * prod.match("prod([lex(sort(\"" + sort +
<      * "\"))], sort(\"<START>\"),no-attrs)") != null ||
<      * prod.match("prod([sort(\"" + sort + "\")], sort(\"<START>\"),no-attrs)")
<      * != null;
<      */
<     IStrategoList lhs = termAt(prod, 0);
<     IStrategoAppl rhs = termAt(prod, 1);
<     String foundSort = prodReader.tryGetFirstSort(lhs);
<     assert foundSort != null;
<     assert "<START>".equals(prodReader.tryGetSort(rhs));
<     return sort.equals(foundSort);
<   }
< 
<   private AbstractParseNode selectOnTopSort(AbstractParseNode t, String sort)
<       throws FilterException {
<     final List<AbstractParseNode> results = new ArrayList<AbstractParseNode>();
< 
<     if (t.isAmbNode()) {
<       addTopSortAlternatives(t, sort, results);
< 
<       switch (results.size()) {
<       case 0:
<         return null;
<       case 1:
<         return results.get(0);
<       default:
<         ambiguityManager.increaseAmbiguityCount();
<         return ParseNode.createAmbNode(results.toArray(new AbstractParseNode[results.size()]));
<       }
<     } else {
<       final IStrategoTerm prod = getProduction(t);
<       return matchProdOnTopSort(prod, sort) ? t : null;
<     }
<   }
< 
<   private void addTopSortAlternatives(AbstractParseNode t, String sort,
<       List<AbstractParseNode> results) throws FilterException {
<     for (final AbstractParseNode amb : t.getChildren()) {
<       if (amb.isAmbNode()) {
<         addTopSortAlternatives(amb, sort, results);
<       } else {
<         final IStrategoTerm prod = getProduction(amb);
<         if (matchProdOnTopSort(prod, sort)) {
<           results.add(amb);
<         }
<       }
<     }
<   }
< 
<   /**
<    * @param inAmbiguityCluster
<    *          We're inside an amb and can return null to reject this branch.
<    * @throws InterruptedException 
<    */
<   public AbstractParseNode filterTree(AbstractParseNode node) throws FilterException, InterruptedException {
<     // SG_FilterTreeRecursive
<     if (Tools.debugging) {
<       Tools.debug("filterTree(node)    - ", node);
<     }
<     
<     LinkedList<AbstractParseNode> input= new LinkedList<AbstractParseNode>();
<     LinkedList<AbstractParseNode> output = new LinkedList<AbstractParseNode>();
<     LinkedList<AbstractParseNode> pending = new LinkedList<AbstractParseNode>();
< 
<     input.push(node);
< 
<     while (!input.isEmpty() || !pending.isEmpty()) {
<       if (Thread.currentThread().isInterrupted())
<         throw new InterruptedException();
<       
<       int pendingPeekPos = pending.isEmpty() ? -1 : output.size() - pending.peek().getChildren().length - 1;
<       if (!pending.isEmpty() && pendingPeekPos >= 0 && output.get(output.size() - pendingPeekPos - 1) == pending.peek()) {
<         AbstractParseNode t = pending.pop();
<         
<         AbstractParseNode[] args = new AbstractParseNode[t.getChildren().length];
<         boolean changed = false;
<         
<         boolean rejected = false;
<         for (int i = t.getChildren().length - 1; i >= 0; i--) {
<           args[i] = output.pop();
<           rejected = rejected || args[i] == null;
<           changed = changed || args[i] != t.getChildren()[i];
<         }
<         
<         output.pop();
<         
<         
<         if (!rejected && changed)
<           t = new ParseNode(t.getLabel(), 
<                             args, 
<                             t.getNodeType(),
<                             t.getLine(),
<                             t.getColumn(),
<                             t.isLayout(),
<                             t.isIgnoreLayout());
<         
<         if (!rejected) 
<           if (LAYOUT_FITERING) {
<             if (!layoutFilter.hasValidLayout((ParseNode) t)) {
<               layoutFiltering++;
<               rejected = true;
<             }
<             else
<               layoutFiltering += layoutFilter.getDisambiguationCount();
<   
<             ambiguityManager.decreaseAmbiguityCount(layoutFilter.getDisambiguationCount());
<           }
<         
<         if (rejected)
<           return null;
<         
<         output.push(t);
<       }
<       else {
<         AbstractParseNode t = input.pop();
<       
<         switch (t.getNodeType()) {
<         case AMBIGUITY:
<           if (!output.isEmpty()) {
<             // (some cycle stuff should be done here)
<             t = filterAmbiguities(t.getChildren());
<             if (t == null)
<               return null;
<             output.push(t);
<           } 
<           // FIXME: hasRejectProd(Amb) can never succeed?
<           else if (filterReject && t.isParseRejectNode())
<               output.push(t);
<           else
<             output.push(filterAmbiguities(t.getChildren()));
<         
<           break;
< 
<         case PARSENODE:
<         case AVOID:
<         case PREFER:
<         case REJECT:
< 
<           boolean rejected = false;
<           
<           if (!rejected && filterReject && t.isParseRejectNode()) {
<             rejected = true;
<           }
<           
<           if (LAYOUT_FITERING) {
<             if (!layoutFilter.hasValidLayout((ParseNode) t)) {
<               layoutFiltering++;
<               rejected = true;
<             }
<             else
<               layoutFiltering += layoutFilter.getDisambiguationCount();
<           }
<           
<           if (!rejected) {
<             t = applyAssociativityPriorityFilter(t);
<             rejected = t == null;
<           }
<           
<           if (rejected)
<             return null;
<           else {
<             output.push(t);
<             if (t.getChildren().length > 0 && !t.isParseProductionChain()) {
<               pending.push(t);
<               for (int i = t.getChildren().length - 1; i >= 0; i--)
<                 input.push(t.getChildren()[i]);
<             }
<           }
<           break;
<         case PARSE_PRODUCTION_NODE:
<           // leaf node -- do nothing (cannot be any ambiguities here)
<           output.push(t);
<           break;
<         case CYCLE:
<           output.push(t);
<           break;
<         default:
<           throw new IllegalStateException("Unknown node type: " + t);
<         }
<       }
<     }
<     
<     assert output.size() == 1;
<     return output.peek();
<   }
< 
<   private AbstractParseNode applyAssociativityPriorityFilter(AbstractParseNode t) {
<     // SG_Associativity_Priority_Filter(pt, t)
<     // - ok
< 
<     if (Tools.debugging) {
<       Tools.debug("applyAssociativityPriorityFilter() - ", t);
<     }
< 
<     if (t.isParseNode()) {
<       final ParseNode n = (ParseNode) t;
<       final Label prodLabel = parseTable.getLabel(n.getLabel());
< 
<       if (filterAssociativity) {
<         if (prodLabel.isLeftAssociative()) {
<           t = applyLeftAssociativeFilter(n, prodLabel);
<         } else if (prodLabel.isRightAssociative()) {
<           t = applyRightAssociativeFilter(n, prodLabel);
<         }
< 
<       }
< 
<       if (filterPriorities && parseTable.hasPriorities()) {
<         if (Tools.debugging) {
<           Tools.debug(" - about to look up : ", prodLabel.labelNumber);
<         }
< 
<         if (!lookupGtrPriority(prodLabel).isEmpty()) {
<           if (Tools.debugging) {
<             Tools.debug(" - found");
<           }
<           return applyPriorityFilter(n, prodLabel);
<         }
<         if (Tools.debugging) {
<           Tools.debug(" - not found");
<         }
<       }
<     }
< 
<     return t;
<   }
< 
<   private AbstractParseNode applyRightAssociativeFilter(ParseNode t,
<       Label prodLabel) {
<     // SG_Right_Associativity_Filter(t, prodl)
<     // - almost ok
< 
<     if (Tools.debugging) {
<       Tools.debug("applyRightAssociativeFilter() - ", t);
<     }
< 
<     final List<AbstractParseNode> newAmbiguities = new ArrayList<AbstractParseNode>();
<     final AbstractParseNode[] kids = t.getChildren();
<     final AbstractParseNode firstKid = kids[0];
< 
<     if (firstKid.isAmbNode()) {
< 
<       for (final AbstractParseNode amb : firstKid.getChildren()) {
<         if (((ParseNode) amb).getLabel() != prodLabel.labelNumber) {
<           newAmbiguities.add(amb);
<         }
<       }
< 
<       final int additionalAmbNodes = newAmbiguities.isEmpty() ? 0 : 1;
<       final AbstractParseNode[] restKids = new AbstractParseNode[kids.length
<           - 1 + additionalAmbNodes];
<       System.arraycopy(kids, 1, restKids, 0, kids.length - 1);
< 
<       // FIXME is this correct?
<       assert !newAmbiguities.isEmpty();
<       AbstractParseNode extraAmb;
<       if (newAmbiguities.size() > 1) {
<         extraAmb = ParseNode.createAmbNode(newAmbiguities.toArray(new AbstractParseNode[newAmbiguities.size()]));
<         ambiguityManager.increaseAmbiguityCount();
<       } else {
<         extraAmb = newAmbiguities.get(0);
<       }
<       restKids[restKids.length - 1] = extraAmb;
<     
<       // FIXME is this correct?
<       return new ParseNode(t.getLabel(), restKids, AbstractParseNode.PARSENODE, t.getLine(), t.getColumn(), t.isLayout(), t.isIgnoreLayout());
< 
<     } else if (firstKid.isParseNode()) {
<       assert ((ParseNode) firstKid).getLabel() != prodLabel.labelNumber;
<     }
<     return t;
<   }
< 
<   private AbstractParseNode applyPriorityFilter(ParseNode t, Label prodLabel) {
<     // SG_Priority_Filter
< 
<     if (Tools.debugging) {
<       Tools.debug("applyPriorityFilter() - ", t);
<     }
< 
<     final List<AbstractParseNode> newAmbiguities = new ArrayList<AbstractParseNode>();
<     final List<AbstractParseNode> newKids = new ArrayList<AbstractParseNode>();
< 
<     final int l0 = prodLabel.labelNumber;
<     int kidnumber = 0;
< 
<     for (final AbstractParseNode kid : t.getChildren()) {
<       AbstractParseNode newKid = kid;
<       final AbstractParseNode injection = jumpOverInjections(kid);
< 
<       if (injection.isAmbNode()) {
<         newAmbiguities.clear();
<         for (final AbstractParseNode amb : injection.getChildren()) {
<           final AbstractParseNode injAmb = jumpOverInjections(amb);
< 
<           if (injAmb.isParseNode()) {
<             final Label label = getProductionLabel(t);
<             if (hasGreaterPriority(l0, label.labelNumber, kidnumber)) {
<               newAmbiguities.add(amb);
<             }
<           }
<         }
< 
<         if (!newAmbiguities.isEmpty()) {
<           AbstractParseNode n = null;
<           if (newAmbiguities.size() > 1) {
<             n = ParseNode.createAmbNode(newAmbiguities.toArray(new AbstractParseNode[newAmbiguities.size()]));
<             ambiguityManager.increaseAmbiguityCount();
<           } else {
<             n = newAmbiguities.get(0);
<           }
<           newKid = replaceUnderInjections(kid, injection, n);
<         } else {
<           // fishy: another filter might be borked
<           assert !filterStrict;
<           // TODO: log or whatever?
<           return t;
<         }
<       } else if (injection.isParseNode()) {
<         final int l1 = ((ParseNode) injection).getLabel();
<         assert !hasGreaterPriority(l0, l1, kidnumber);
<       }
< 
<       newKids.add(newKid);
<       kidnumber++;
<     }
< 
<     // FIXME (KTK) get rid of toArray by precomputing the necessary size of
<     // newKids earlier in the method
<     return new ParseNode(t.getLabel(),
<         newKids.toArray(new AbstractParseNode[newKids.size()]), AbstractParseNode.PARSENODE, t.getLine(), t.getColumn(), t.isLayout(), t.isIgnoreLayout());
<   }
< 
<   private AbstractParseNode replaceUnderInjections(AbstractParseNode alt,
<       AbstractParseNode injection, AbstractParseNode n)  {
<     // SG_Replace_Under_Injections
<     // - not ok
< 
<     assert false;
<     return null;
<     
< //    throw new FilterException(parser,
< //        "replaceUnderInjections is not implemented",
< //        new NotImplementedException());
<     /*
<      * if (ATisEqual(t, injT)) { return newTree; } else { IStrategoList sons =
<      * (IStrategoList)ATgetArgument((ATerm) t, 1); tree newSon =
<      * SG_Replace_Under_Injections((tree)ATgetFirst(sons), injT, newTree);
<      * return ATsetArgument((ATermAppl)t, (ATerm)ATmakeList1((ATerm)newSon), 1);
<      * }
<      */
<   }
< 
<   private AbstractParseNode jumpOverInjections(AbstractParseNode t) {
< 
<     if (Tools.debugging) {
<       Tools.debug("jumpOverInjections() - ", t);
<     }
< 
<     if (t.isParseNode()) {
<       int prod = ((ParseNode) t).getLabel();
<       ParseNode n = (ParseNode) t;
<       while (isUserDefinedLabel(prod)) {
<         final AbstractParseNode x = n.kids[0];
<         if (x.isParseNode()) {
<           n = (ParseNode) x;
<           prod = n.getLabel();
<         } else {
<           return x;
<         }
<       }
<     }
< 
<     return t;
<   }
< 
<   // TODO: shouldn't this be called isInjection?
< 
<   private boolean isUserDefinedLabel(int prod) {
<     final Label l = parseTable.lookupInjection(prod);
<     if (l == null) {
<       return false;
<     }
<     return l.isInjection();
<   }
< 
<   private boolean hasGreaterPriority(int l0, int l1, int arg) {
<     final List<Priority> prios = lookupGtrPriority(parseTable.getLabel(l0));
< 
<     for (int i = 0, size = prios.size(); i < size; i++) {
<       final Priority p = prios.get(i);
<       if (l1 == p.right) {
<         if (p.arg == -1 || p.arg == arg) {
<           return true;
<         }
<       }
<     }
<     return false;
<   }
< 
<   private List<Priority> lookupGtrPriority(Label prodLabel) {
<     return parseTable.getPriorities(prodLabel);
<   }
< 
<   private AbstractParseNode applyLeftAssociativeFilter(ParseNode t,
<       Label prodLabel) {
<     // SG_Right_Associativity_Filter()
< 
<     if (Tools.debugging) {
<       Tools.debug("applyLeftAssociativeFilter() - ", t);
<     }
< 
<     final List<AbstractParseNode> newAmbiguities = new ArrayList<AbstractParseNode>();
<     final AbstractParseNode[] kids = t.kids;
<     AbstractParseNode last = kids[kids.length - 1];
< 
<     if (last.isAmbNode()) {
< 
<       for (final AbstractParseNode amb : last.getChildren()) {
<         if (amb.isAmbNode()
<             || !parseTable.getLabel(((ParseNode) amb).getLabel()).equals(
<                 prodLabel)) {
<           newAmbiguities.add(amb);
<         }
<       }
< 
<       assert !newAmbiguities.isEmpty();
<       final AbstractParseNode[] rest = new AbstractParseNode[kids.length];
<       for (int i = 0; i < kids.length - 1; i++) {
<         rest[i] = kids[i];
<       }
< 
<       if (newAmbiguities.size() > 1) {
<         last = ParseNode.createAmbNode(newAmbiguities.toArray(new AbstractParseNode[newAmbiguities.size()]));
<         ambiguityManager.increaseAmbiguityCount();
<       } else {
<         last = newAmbiguities.get(0);
<       }
<       rest[rest.length - 1] = last;
<       ambiguityManager.increaseAmbiguityCount();
<       return new ParseNode(t.getLabel(), rest, AbstractParseNode.PARSENODE, t.getLine(), t.getColumn(), t.isLayout(), t.isIgnoreLayout());
<     } 
<     else if (last.isParseNode()) {
<       final Label other = parseTable.getLabel(((ParseNode) last).getLabel());
<       assert !prodLabel.equals(other);
<     }
< 
<     return t;
<   }
< 
<   private Label getProductionLabel(AbstractParseNode t) {
<     if (t.isParseNode()) {
<       return parseTable.getLabel(((ParseNode) t).getLabel());
<     } else if (t instanceof ParseProductionNode) {
<       return parseTable.getLabel(((ParseProductionNode) t).getLabel());
<     }
<     return null;
<   }
< 
<   private AbstractParseNode filterAmbiguities(AbstractParseNode[] ambs) throws FilterException, InterruptedException {
<     if (ambs.length == 0)
<       return null;
<     AbstractParseNode current = ambs[0];
<     for (int i = 1; i < ambs.length; i++)
<       current = filterAmbiguities(current, ambs[i]);
<     
<     return current;
<   }
<   
<   private AbstractParseNode filterAmbiguities(AbstractParseNode amb1, AbstractParseNode amb2)
<       throws FilterException, InterruptedException {
<     // SG_FilterAmb
< 
<     if (Tools.debugging) {
<       Tools.debug("filterAmbiguities() - [", 2, "]");
<     }
< 
<     amb1 = filterTree(amb1);
<     amb2 = filterTree(amb2);
<     
<     if (amb1 == null)
<       return amb2;
<     if (amb2 == null)
<       return amb1;
<     
<     switch (filter(amb1, amb2)) {
<     case FILTER_DRAW:
<       ambiguityManager.increaseAmbiguityCount();
<       return ParseNode.createAmbNode(amb1, amb2);
<     case FILTER_LEFT_WINS:
<       return amb1;
<     case FILTER_RIGHT_WINS:
<       return amb2;
<     default:
<       return null;
<     }
<   }
< 
<   private int filter(AbstractParseNode left, AbstractParseNode right) {
<     // SG_Filter(t0, t1)
< 
<     if (Tools.debugging) {
<       Tools.debug("filter()");
<     }
< 
<     if (left.equals(right)) {
<       return FILTER_LEFT_WINS;
<     }
< 
<     /*
<      * UNDONE: direct eagerness filter seems to be disabled in reference SGLR if
<      * (filterDirectPreference && parseTable.hasPrefersOrAvoids()) { int r =
<      * filterOnDirectPrefers(left, right); if (r != FILTER_DRAW) return r; }
<      */
< 
<     // like C-SGLR, we use indirect preference filtering if the direct one is
<     // enabled
<     if (filterDirectPreference && parseTable.hasPrefersOrAvoids()) {
<       final int r = filterOnIndirectPrefers(left, right);
<       if (r != FILTER_DRAW) {
<         return r;
<       }
<     }
< 
<     if (filterPreferenceCount && parseTable.hasPrefersOrAvoids()) {
<       final int r = filterOnPreferCount(left, right);
<       if (r != FILTER_DRAW) {
<         return r;
<       }
<     }
< 
<     if (filterInjectionCount) {
<       final int r = filterOnInjectionCount(left, right);
<       if (r != FILTER_DRAW) {
<         return r;
<       }
<     }
<     
<     if (filterLongestMatch) {
<       final int r = filterLongestMatch(left, right);
<       if (r != FILTER_DRAW) {
<         return r;
<       }
<     }
<     
<     return filterPermissiveLiterals(left, right);
<   }
< 
<   private int filterPermissiveLiterals(AbstractParseNode left,
<       AbstractParseNode right) {
<     // Work-around for http://bugs.strategoxt.org/browse/SPI-5 (Permissive
<     // grammars introduce ambiguities for literals)
< 
<     if (left.isParseNode() && right.isParseNode()) {
<       final AbstractParseNode[] leftKids = ((ParseNode) left).kids;
<       final AbstractParseNode[] rightKids = ((ParseNode) right).kids;
<       if (leftKids.length > 0 && rightKids.length == 1) {
<         if (leftKids[0].isParseProductionNode()
<             && rightKids[0].equals(left)) {
<           return FILTER_LEFT_WINS;
<         }
<       }
<       if (rightKids.length > 0 && leftKids.length == 1) {
<         if (rightKids[0].isParseProductionNode()
<             && leftKids[0].equals(right)) {
<           return FILTER_RIGHT_WINS;
<         }
<       }
<     }
<     return FILTER_DRAW;
<   }
< 
<   private int filterOnInjectionCount(AbstractParseNode left,
<       AbstractParseNode right) {
< 
<     if (Tools.debugging) {
<       Tools.debug("filterOnInjectionCount()");
<     }
< 
<     ambiguityManager.increaseInjectionCount();
< 
<     final int leftInjectionCount = countAllInjections(left);
<     final int rightInjectionCount = countAllInjections(right);
< 
<     if (leftInjectionCount != rightInjectionCount) {
<       ambiguityManager.increaseInjectionFilterSucceededCount();
<     }
< 
<     if (leftInjectionCount > rightInjectionCount) {
<       return FILTER_RIGHT_WINS;
<     } else if (rightInjectionCount > leftInjectionCount) {
<       return FILTER_LEFT_WINS;
<     }
< 
<     return FILTER_DRAW;
<   }
< 
<   private int countAllInjections(AbstractParseNode t) {
<     // SG_CountAllInjectionsInTree
<     // - ok
<     if (t.isAmbNode()) {
<       // Trick from forest.c
<       return t.getChildren().length == 0 ? 0 : countAllInjections(t
<           .getChildren()[0]);
<     } else if (t.isParseNode()) {
<       final int c = getProductionLabel(t).isInjection() ? 1 : 0;
<       return c + countAllInjections(((ParseNode) t).kids);
<     }
<     return 0;
<   }
< 
<   private int countAllInjections(AbstractParseNode[] ls) {
<     // SG_CountAllInjectionsInTree
<     // - ok
<     int r = 0;
<     for (int i = 0, max = ls.length; i < max; i++) {
<       r += countAllInjections(ls[i]);
<     }
<     return r;
<   }
< 
<   private int filterOnPreferCount(AbstractParseNode left,
<       AbstractParseNode right) {
< 
<     if (Tools.debugging) {
<       Tools.debug("filterOnPreferCount()");
<     }
< 
<     ambiguityManager.increaseEagernessFilterCalledCount();
< 
<     int r = FILTER_DRAW;
<     if (parseTable.hasPrefers() || parseTable.hasAvoids()) {
<       final int leftPreferCount = countPrefers(left);
<       final int rightPreferCount = countPrefers(right);
<       final int leftAvoidCount = countAvoids(left);
<       final int rightAvoidCount = countAvoids(right);
< 
<       if ((leftPreferCount > rightPreferCount && leftAvoidCount <= rightAvoidCount)
<           || (leftPreferCount == rightPreferCount && leftAvoidCount < rightAvoidCount)) {
<         Tools.logger("Eagerness priority: ", left, " > ", right);
<         r = FILTER_LEFT_WINS;
<       }
< 
<       if ((rightPreferCount > leftPreferCount && rightAvoidCount <= leftAvoidCount)
<           || (rightPreferCount == leftPreferCount && rightAvoidCount < leftAvoidCount)) {
<         if (r != FILTER_DRAW) {
<           Tools.logger("Symmetric eagerness priority: ", left, " == ", right);
<           r = FILTER_DRAW;
---
> 	private boolean filterCycles;
> 
> 	private boolean filterDirectPreference;
> 
> 	private boolean filterPreferenceCount;
> 
> 	private boolean filterInjectionCount;
> 
> 	private boolean filterTopSort;
> 
> 	private boolean filterReject;
> 
> 	private boolean filterAssociativity;
> 
> 	private boolean filterPriorities;
> 
> 	private boolean filterStrict;
> 
> 	private boolean logStatistics;
> 
> 	private boolean ambiguityIsError;
> 	
> 	/**
> 	 * A parse node that was rejected in the current subtree,
> 	 * or null if no parse node was rejected.
> 	 */
> 	private AbstractParseNode rejectedBranch;
> 
> 	// Current parser state
> 
> 	private AmbiguityManager ambiguityManager;
> 
> 	private SGLR parser;
> 
> 	private ParseTable parseTable;
> 
> 	private ProductionAttributeReader prodReader;
> 
> 	// private Map<AmbKey, IParseNode> resolvedTable = new HashMap<AmbKey, IParseNode>();
> 
> 	/**
> 	 * Sets whether any filter should be applied at all (excluding the top sort filter).
> 	 */
> 	public final void setFilterAny(boolean filterAny) {
> 		this.filterAny = filterAny;
> 	}
> 
> 	public final void setFilterDirectPreference(boolean filterDirectPreference) {
> 		this.filterDirectPreference = filterDirectPreference;
> 	}
> 
> 	public boolean getFilterDirectPreference() {
> 		return filterDirectPreference;
> 	}
> 
> 	/**
> 	 * For preference count filtering, see {@link #setFilterPreferenceCount(boolean)}.
> 	 */
> 	@Deprecated
> 	public final void setFilterIndirectPreference(boolean filterIndirectPreference) {
> 		throw new UnsupportedOperationException();
> 	}
> 
> 	/**
> 	 * For preference count filtering, see {@link #getFilterPreferenceCount()}.
> 	 */
> 	@Deprecated
> 	public boolean getFilterIndirectPreference() {
> 		throw new UnsupportedOperationException();
> 	}
> 
> 	public final void setFilterInjectionCount(boolean filterInjectionCount) {
> 		this.filterInjectionCount = filterInjectionCount;
> 	}
> 
> 	public boolean getFilterInjectionCount() {
> 		return filterInjectionCount;
> 	}
> 
> 	public final void setFilterPreferenceCount(boolean filterPreferenceCount) {
> 		this.filterPreferenceCount = filterPreferenceCount;
> 	}
> 
> 	public boolean getFilterPreferenceCount() {
> 		return filterPreferenceCount;
> 	}
> 
> 	public final void setFilterTopSort(boolean filterTopSort) {
> 		this.filterTopSort = filterTopSort;
> 	}
> 
> 	public boolean getFilterTopSort() {
> 		return filterTopSort;
> 	}
> 
> 	public void setFilterCycles(boolean filterCycles) {
> 		this.filterCycles = filterCycles;
> 	}
> 
> 	public boolean isFilterCycles() {
> 		return filterCycles;
> 	}
> 
> 	public void setFilterAssociativity(boolean filterAssociativity) {
> 		this.filterAssociativity = filterAssociativity;
> 	}
> 
> 	public boolean getFilterAssociativity() {
> 		return filterAssociativity;
> 	}
> 
> 	public void setFilterPriorities(boolean filterPriorities) {
> 		this.filterPriorities = filterPriorities;
> 	}
> 
> 	public boolean getFilterPriorities() {
> 		return filterPriorities;
> 	}
> 
> 	/**
> 	 * Sets whether to enable strict filtering, triggering a
> 	 * FilterException when the priorities filter encounters
> 	 * an unfiltered ambiguity.
> 	 */
> 	public void setFilterStrict(boolean filterStrict) {
> 		this.filterStrict = filterStrict;
> 	}
> 
> 	public boolean getFilterStrict() {
> 		return filterStrict;
> 	}
> 
> 	public final void setHeuristicFilters(boolean heuristicFilters) {
> 		setFilterPreferenceCount(heuristicFilters);
> 		setFilterInjectionCount(heuristicFilters);
> 	}
> 
> 	public void setFilterReject(boolean filterReject) {
> 		this.filterReject = filterReject;
> 	}
> 
> 	public boolean getFilterReject() {
> 		return filterReject;
> 	}
> 
> 	public void setLogStatistics(boolean logStatistics) {
> 		this.logStatistics = logStatistics;
> 	}
> 
> 	public boolean getLogStatistics() {
> 		return logStatistics;
> 	}
> 
> 	public void setAmbiguityIsError(boolean ambiguityIsError) {
> 		this.ambiguityIsError = ambiguityIsError;
> 	}
> 
> 	public boolean getAmbiguityIsError() {
> 		return ambiguityIsError;
> 	}
> 
> 	public final void setDefaultFilters() {
> 		filterAny = true;
> 		filterCycles = false; // TODO: filterCycles; enable by default
> 		filterDirectPreference = true;
> 		filterPreferenceCount = false;
> 		filterInjectionCount = false;
> 		filterTopSort = true;
> 		filterReject = true;
> 		filterAssociativity = true;
> 		filterPriorities = true;
> 		filterStrict = false; // TODO: disable filterStrict hack
> 		logStatistics = true;
> 		ambiguityIsError = false;
> 	}
> 
> 	public Disambiguator() {
> 		setDefaultFilters();
> 	}
> 
>     public Object applyFilters(SGLR parser, AbstractParseNode root, String sort, int inputLength) throws SGLRException, FilterException {
>     	AbstractParseNode t = root;
> 		if(Tools.debugging) {
> 			Tools.debug("applyFilters()");
> 		}
> 
>     	try {
>     		try {
> 	            if(Tools.debugging) {
> 	                Tools.debug("applyFilters()");
> 	            }
> 
> 	            initializeFromParser(parser);
> 	            t = applyTopSortFilter(sort, t);
> 
> 	            if (filterAny) {
> 	                t = applyCycleDetectFilter(t);
> 
> 	                // SG_FilterTree
> 	                ambiguityManager.resetClustersVisitedCount();
> 	                t = filterTree(t, false);
> 	            }
> 
> 				if (filterReject && rejectedBranch != null && !parser.useIntegratedRecovery)
> 					throw new FilterException(parser, "Unexpected reject annotation in " + yieldTree(rejectedBranch));
> 	        } catch (RuntimeException e) {
> 	            throw new FilterException(parser, "Runtime exception when applying filters", e);
> 	        } finally {
> 	        	rejectedBranch = null;
> 	        }
> 
> 	        return yieldTreeTop(t);
> 
>         } finally {
>             initializeFromParser(null);
>         }
>     }
> 
> 	private void initializeFromParser(SGLR parser) {
> 		if (parser == null) {
> 			this.parser = null;
> 			parseTable = null;
> 			ambiguityManager = null;
> 		} else {
> 			this.parser = parser;
> 			parseTable = parser.getParseTable();
> 			prodReader = new ProductionAttributeReader(parseTable.getFactory());
> 			ambiguityManager = parser.getAmbiguityManager();
> 		}
> 	}
> 
> 	private void logStatus() {
> 		Tools.logger("Number of rejects: ", parser.getRejectCount());
> 		Tools.logger("Number of reductions: ", parser.getReductionCount());
> 		Tools.logger("Number of ambiguities: ", ambiguityManager.getMaxNumberOfAmbiguities());
> 		Tools.logger("Number of calls to Amb: ", ambiguityManager.getAmbiguityCallsCount());
> 		Tools.logger("Count Eagerness Comparisons: ", ambiguityManager.getEagernessComparisonCount(), " / ", ambiguityManager.getEagernessSucceededCount());
> 		Tools.logger("Number of Injection Counts: ", ambiguityManager.getInjectionCount());
> 	}
> 
>     private Object yieldTree(AbstractParseNode t) {
> 		parser.getTreeBuilder().reset(); // in case yieldTree is used for debugging
> 		return parser.getTreeBuilder().buildTree(t);
>     }
> 
>     private Object yieldTreeTop(AbstractParseNode t) throws SGLRException {
>         int ambCount = ambiguityManager.getAmbiguitiesCount();
> 
> 		if (Tools.debugging) {
> 			Tools.debug("convertToATerm: ", t);
> 		}
> 
> 		try {
> 			ambiguityManager.resetAmbiguityCount();
> 			final Object r = yieldTree(t);
> 
> 			if(logStatistics)
> 				logStatus();
> 
> 	        if (Tools.debugging) {
> 	            Tools.debug("yield: ", r);
> 	        }
> 
> 	        if(ambiguityIsError && ambCount > 0) {
> 	        	throw new SGLRException(parser, "Ambiguities found") ;
> 	        }
> 	        else {
> 	        	return parser.getTreeBuilder().buildTreeTop(r, ambCount);
> 	        }
> 		} finally {
> 			parser.getTreeBuilder().reset();
> 		}
>     }
> 
> 	private AbstractParseNode applyCycleDetectFilter(AbstractParseNode t) throws FilterException {
> 
> 		if (Tools.debugging) {
> 			Tools.debug("applyCycleDetectFilter() - ", t);
> 		}
> 
> 		if (filterCycles) {
> 			if (ambiguityManager.getMaxNumberOfAmbiguities() > 0) {
> 				if (isCyclicTerm(t)) {
> 					throw new FilterException(parser, "Term is cyclic");
> 				}
> 			}
> 		}
> 
> 		return t;
> 	}
> 
> 	private IStrategoTerm getProduction(AbstractParseNode t) {
> 		if (t.isParseNode()) {
> 			return parseTable.getProduction(((ParseNode) t).getLabel());
> 		} else {
> 			return parseTable.getProduction(((ParseProductionNode) t).getProduction());
> 		}
> 	}
> 
> 	private AbstractParseNode applyTopSortFilter(String sort, AbstractParseNode t) throws SGLRException {
> 
> 		if (Tools.debugging) {
> 			Tools.debug("applyTopSortFilter() - ", t);
> 		}
> 
> 		if (sort != null && filterTopSort) {
> 			t = selectOnTopSort(t, sort);
> 			if (t == null) {
> 				throw new StartSymbolException(parser, "Desired start symbol not found: " + sort);
> 			}
> 		}
> 
> 		return t;
> 	}
> 
> 	private boolean matchProdOnTopSort(IStrategoTerm prod, String sort) throws FilterException {
> 		assert sort != null;
> 		/*
> 		sort = sort.replaceAll("\"", "");
> 		return prod.match("prod([cf(opt(layout)),cf(sort(\"" + sort + "\")),cf(opt(layout))], sort(\"<START>\"),no-attrs)") != null
> 		|| prod.match("prod([cf(sort(\"" + sort + "\"))], sort(\"<START>\"),no-attrs)") != null
> 		|| prod.match("prod([lex(sort(\"" + sort + "\"))], sort(\"<START>\"),no-attrs)") != null
> 		|| prod.match("prod([sort(\"" + sort + "\")], sort(\"<START>\"),no-attrs)") != null;
> 		*/
> 		IStrategoList lhs = termAt(prod, 0);
> 		IStrategoAppl rhs = termAt(prod, 1);
> 		String foundSort = prodReader.tryGetFirstSort(lhs);
> 		assert foundSort != null;
> 		assert "<START>".equals(prodReader.tryGetSort(rhs));
> 		return sort.equals(foundSort);
> 	}
> 
> 	private AbstractParseNode selectOnTopSort(AbstractParseNode t, String sort) throws FilterException {
> 		final List<AbstractParseNode> results = new ArrayList<AbstractParseNode>();
> 
> 		if (t.isAmbNode()) {
> 			addTopSortAlternatives(t, sort, results);
> 
> 			switch (results.size()) {
> 			case 0: return null;
> 			case 1: return results.get(0);
> 			default:
> 				ambiguityManager.increaseAmbiguityCount();
> 				return ParseNode.createAmbNode(results.toArray(new AbstractParseNode[results.size()]));
> 			}
> 		} else {
> 			final IStrategoTerm prod = getProduction(t);
> 			return matchProdOnTopSort(prod, sort) ? t : null;
> 		}
> 	}
> 
> 	private void addTopSortAlternatives(AbstractParseNode t, String sort, List<AbstractParseNode> results) throws FilterException {
> 		for(final AbstractParseNode amb : t.getChildren()) {
> 			if (amb.isAmbNode()) {
> 				addTopSortAlternatives(amb, sort, results);
> 			} else {
> 				final IStrategoTerm prod = getProduction(amb);
> 				if (matchProdOnTopSort(prod, sort)) {
> 					results.add(amb);
> 				}
> 			}
> 		}
> 	}
> 
> 	
> 	/**
> 	 * Performs a depth-first traversal of the parse tree to
> 	 * filter ambiguities. 
> 	 */
> 	public AbstractParseNode filterTree(AbstractParseNode node,
> 			boolean inAmbiguityCluster) throws FilterException {
> 		// SG_FilterTreeRecursive
> 		if (Tools.debugging) {
> 			Tools.debug("filterTree(node)    - ", node);
> 		}
> 
> 		// nodes to be processed
> 		Stack<AbstractParseNode> input = new Stack<AbstractParseNode>();
> 		// nodes already processed
> 		Stack<AbstractParseNode> output = new Stack<AbstractParseNode>();
> 		// already processed nodes that have not yet been reinitialized
> 		// with their (possibly changed) children
> 		Stack<AbstractParseNode> pending = new Stack<AbstractParseNode>();
> 
> 		input.add(node);
> 
> 		while (!input.isEmpty() || !pending.isEmpty()) {
> 			int pendingPeekPos = pending.isEmpty() ? -1 : output.size()
> 					- pending.peek().getChildren().length - 1;
> 			
> 			if (!pending.isEmpty() && pendingPeekPos >= 0
> 					&& output.get(pendingPeekPos) == pending.peek()) {
> 				// collapse pending.peek() with its possibly changed children
> 				
> 				AbstractParseNode t = pending.pop();
> 
> 				AbstractParseNode[] args = new AbstractParseNode[t
> 						.getChildren().length];
> 				boolean changed = false;
> 
> 				for (int i = t.getChildren().length - 1; i >= 0; i--) {
> 					args[i] = output.pop();
> 					changed = changed || args[i] != t.getChildren()[i];
> 				}
> 
> 				output.pop();
> 
> 				if (changed)
> 					t = new ParseNode(t.getLabel(), args, t.getNodeType());
> 
> 				if (filterAssociativity)
> 					t = applyAssociativityPriorityFilter(t);
> 
> 				output.push(t);
> 			} else {
> 				// examine input.peek() and traverse its children
> 				
> 				AbstractParseNode t = input.pop();
> 
> 				switch (t.getNodeType()) {
> 				case AMBIGUITY:
> 					if (!(inAmbiguityCluster && output.isEmpty())) {
> 						// (some cycle stuff should be done here)
> 						final AbstractParseNode[] ambs = t.getChildren();
> 						t = filterAmbiguities(ambs);
> 						output.push(t);
> 					} else {
> 						// FIXME: hasRejectProd(Amb) can never succeed?
> 						if (filterReject && parseTable.hasRejects()
> 								&& hasRejectProd(t)) {
> 							output.push(t);
> 						} else {
> 							final AbstractParseNode[] ambs = t.getChildren();
> 							output.push(filterAmbiguities(ambs));
> 						}
> 
> 					}
> 					break;
> 				case PARSENODE:
> 				case AVOID:
> 				case PREFER:
> 				case REJECT:
> 
> 					if (filterReject && parseTable.hasRejects()
> 							&& hasRejectProd(t)) {
> 						output.push(t);
> 						rejectedBranch = t;
> 					} else if (t.getChildren().length > 0
> 							&& !t.isParseProductionChain()) {
> 						output.push(t);
> 						pending.push(t);
> 						for (int i = t.getChildren().length - 1; i >= 0; i--)
> 							input.push(t.getChildren()[i]);
> 					} else {
> 						output.push(t);
> 					}
> 					break;
> 				case PARSE_PRODUCTION_NODE:
> 					// leaf node -- do thing (cannot be any ambiguities here)
> 					output.push(t);
> 					break;
> 				case CYCLE:
> 					output.push(t);
> 					break;
> 				default:
> 					throw new IllegalStateException("Unknown node type: " + t);
> 				}
> 			}
> 		}
> 
> 		assert output.size() == 1;
> 		return output.peek();
> 	}
> 
> 	private AbstractParseNode applyAssociativityPriorityFilter(AbstractParseNode t) throws FilterException {
> 		// SG_Associativity_Priority_Filter(pt, t)
> 		// - ok
> 
> 		if(Tools.debugging) {
> 			Tools.debug("applyAssociativityPriorityFilter() - ", t);
> 		}
> 
> 		AbstractParseNode r = t;
> 
> 		if (t.isParseNode()) {
> 			final Label prodLabel = getProductionLabel(t);
> 			final ParseNode n = (ParseNode) t;
> 
> 			if (filterAssociativity) {
> 				if (prodLabel.isLeftAssociative()) {
> 					r = applyLeftAssociativeFilter(n, prodLabel);
> 				} else if (prodLabel.isRightAssociative()) {
> 					r = applyRightAssociativeFilter(n, prodLabel);
> 				}
> 
> 			}
> 
> 			if (filterPriorities && parseTable.hasPriorities()) {
> 				if(Tools.debugging) {
> 					Tools.debug(" - about to look up : ",  prodLabel.labelNumber);
> 				}
> 
> 				if (!lookupGtrPriority(prodLabel).isEmpty()) {
> 					if(Tools.debugging) {
> 						Tools.debug(" - found");
> 					}
> 					if (r.isAmbNode()) {
> 						return r;
> 					}
> 					return applyPriorityFilter((ParseNode) r, prodLabel);
> 				}
> 				if(Tools.debugging) {
> 					Tools.debug(" - not found");
> 				}
> 			}
> 		}
> 
> 		return r;
> 	}
> 
> 	private AbstractParseNode applyRightAssociativeFilter(ParseNode t, Label prodLabel) throws FilterException {
> 		// SG_Right_Associativity_Filter(t, prodl)
> 		// - almost ok
> 
> 		if(Tools.debugging) {
> 			Tools.debug("applyRightAssociativeFilter() - ", t);
> 		}
> 
> 		final List<AbstractParseNode> newAmbiguities = new ArrayList<AbstractParseNode>();
> 		final AbstractParseNode[] kids = t.getChildren();
> 		final AbstractParseNode firstKid = kids[0];
> 
> 		if(firstKid.isAmbNode()) {
> 
> 			for (final AbstractParseNode amb : firstKid.getChildren()) {
> 				if(amb.isAmbNode()
> 						|| ((ParseNode)amb).getLabel() != prodLabel.labelNumber) {
> 					newAmbiguities.add(amb);
> 				}
> 			}
> 
> 			// FIXME is this correct?
> 					if(!newAmbiguities.isEmpty()) {
> 
> 						final AbstractParseNode[] restKids = new AbstractParseNode[kids.length];
> 						for(int i = 1; i < restKids.length; i++) {
> 							restKids[i] = kids[i];
> 						}
> 						
> 						AbstractParseNode extraAmb;
> 						if(newAmbiguities.size() > 1) {
> 							extraAmb = ParseNode.createAmbNode(newAmbiguities.toArray(new AbstractParseNode[newAmbiguities.size()]));
> 							ambiguityManager.increaseAmbiguityCount();
> 						} else {
> 							extraAmb = newAmbiguities.get(0);
> 						}
> 						restKids[0] = extraAmb;
> 
> 						return new ParseNode(t.getLabel(), restKids, AbstractParseNode.PARSENODE);
> 					} else {
> 						throw new FilterException(parser);
> 					}
> 
> 		} else if(firstKid.isParseNode()) {
> 			if(((ParseNode)firstKid).getLabel() == prodLabel.labelNumber) {
> 				throw new FilterException(parser);
> 			}
> 		}
> 		return t;
> 	}
> 
> 	private AbstractParseNode applyPriorityFilter(ParseNode t, Label prodLabel) throws FilterException {
> 		// SG_Priority_Filter
> 
> 		if(Tools.debugging) {
> 			Tools.debug("applyPriorityFilter() - ", t);
> 		}
> 
> 		final List<AbstractParseNode> newAmbiguities = new ArrayList<AbstractParseNode>();
> 		final List<AbstractParseNode> newKids = new ArrayList<AbstractParseNode>();
> 
> 		final int l0 = prodLabel.labelNumber;
> 		int kidnumber = 0;
> 
> 		for (final AbstractParseNode kid : t.getChildren()) {
> 			AbstractParseNode newKid = kid;
> 			final AbstractParseNode injection = jumpOverInjections(kid);
> 
> 			if (injection.isAmbNode()) {
> 				newAmbiguities.clear();
> 				for (final AbstractParseNode amb : injection.getChildren()) {
> 					final AbstractParseNode injAmb = jumpOverInjections(amb);
> 
> 					if (injAmb.isParseNode()) {
> 						final Label label = getProductionLabel(t);
> 						if(hasGreaterPriority(l0, label.labelNumber, kidnumber)) {
> 							newAmbiguities.add(amb);
> 						}
> 					}
> 				}
> 
> 				if(!newAmbiguities.isEmpty()) {
> 					AbstractParseNode n = null;
> 					if(newAmbiguities.size() > 1) {
> 						n = ParseNode.createAmbNode(newAmbiguities.toArray(new AbstractParseNode[newAmbiguities.size()]));
> 						ambiguityManager.increaseAmbiguityCount();
> 					} else {
> 						n = newAmbiguities.get(0);
> 					}
> 					newKid = replaceUnderInjections(kid, injection, n);
> 				} else {
> 					// fishy: another filter might be borked
> 					if (filterStrict) {
> 						throw new FilterException(parser);
> 					} else {
> 						// TODO: log or whatever?
> 								return t;
> 					}
> 				}
> 			} else if (injection.isParseNode()) {
> 				final int l1 = ((ParseNode) injection).getLabel();
> 				if (hasGreaterPriority(l0, l1, kidnumber)) {
> 					throw new FilterException(parser);
> 				}
> 			}
> 
> 			newKids.add(newKid);
> 			kidnumber++;
> 		}
> 
> 		// FIXME (KTK) get rid of toArray by precomputing the necessary size of newKids earlier in the method
> 		return new ParseNode(t.getLabel(), newKids.toArray(new AbstractParseNode[newKids.size()]), AbstractParseNode.PARSENODE);
> 	}
> 
> 	private AbstractParseNode replaceUnderInjections(AbstractParseNode alt, AbstractParseNode injection, AbstractParseNode n)
> 			throws FilterException {
> 		// SG_Replace_Under_Injections
> 		// - not ok
> 
> 		throw new FilterException(parser, "replaceUnderInjections is not implemented", new NotImplementedException());
> 		/*
>         if (ATisEqual(t, injT)) {
>            return newTree;
1066,1067c689,1313
<           Tools.logger("Eagerness priority: ", right, " > ", left);
<           r = FILTER_RIGHT_WINS;
---
>           IStrategoList sons = (IStrategoList)ATgetArgument((ATerm) t, 1);
>           tree newSon = SG_Replace_Under_Injections((tree)ATgetFirst(sons),
>                                                     injT, newTree);
>           return ATsetArgument((ATermAppl)t, (ATerm)ATmakeList1((ATerm)newSon), 1);
>         }
> 		 */
> 	}
> 
> 	private AbstractParseNode jumpOverInjections(AbstractParseNode t) {
> 
> 		if(Tools.debugging) {
> 			Tools.debug("jumpOverInjections() - ", t);
> 		}
> 
> 		if (t.isParseNode()) {
> 			int prod = ((ParseNode) t).getLabel();
> 			ParseNode n = (ParseNode)t;
> 			while (isUserDefinedLabel(prod)) {
> 				final AbstractParseNode x = n.kids[0];
> 				if(x.isParseNode()) {
> 					n = (ParseNode)x;
> 					prod = n.getLabel();
> 				} else {
> 					return x;
> 				}
> 			}
> 		}
> 
> 		return t;
> 	}
> 
> 	// TODO: shouldn't this be called isInjection?
> 
> 	private boolean isUserDefinedLabel(int prod) {
> 		final Label l = parseTable.lookupInjection(prod);
> 		if(l == null) {
> 			return false;
> 		}
> 		return l.isInjection();
> 	}
> 
> 	private boolean hasGreaterPriority(int l0, int l1, int arg) {
> 		final List<Priority> prios = lookupGtrPriority(parseTable.getLabel(l0));
> 
> 		for (int i = 0, size = prios.size(); i < size; i++) {
> 			final Priority p = prios.get(i);
> 			if (l1 == p.right) {
> 				if (p.arg == -1 || p.arg == arg) {
> 					return true;
> 				}
> 			}
> 		}
> 		return false;
> 	}
> 
> 	private List<Priority> lookupGtrPriority(Label prodLabel) {
> 		return parseTable.getPriorities(prodLabel);
> 	}
> 
> 	private AbstractParseNode applyLeftAssociativeFilter(ParseNode t, Label prodLabel) throws FilterException {
> 		// SG_Right_Associativity_Filter()
> 
> 		if(Tools.debugging) {
> 			Tools.debug("applyLeftAssociativeFilter() - ", t);
> 		}
> 
> 		final List<AbstractParseNode> newAmbiguities = new ArrayList<AbstractParseNode>();
> 		final AbstractParseNode[] kids = t.kids;
> 		AbstractParseNode last = kids[kids.length - 1];
> 
> 		if (last.isAmbNode()) {
> 
> 			for (final AbstractParseNode amb : last.getChildren()) {
> 				if (amb.isAmbNode()
> 						|| !parseTable.getLabel(((ParseNode) amb).getLabel()).equals(prodLabel)) {
> 					newAmbiguities.add(amb);
> 				}
> 			}
> 
> 			if (!newAmbiguities.isEmpty()) {
> 				final AbstractParseNode[] rest = new AbstractParseNode[kids.length];
> 				for(int i = 0; i < kids.length - 1; i++) {
> 					rest[i] = kids[i];
> 				}
> 
> 				
> 				if (newAmbiguities.size() > 1) {
> 					last = ParseNode.createAmbNode(newAmbiguities.toArray(new AbstractParseNode[newAmbiguities.size()]));
> 					ambiguityManager.increaseAmbiguityCount();
> 				} else {
> 					last = newAmbiguities.get(0);
> 				}
> 				rest[rest.length - 1] = last;
> 				ambiguityManager.increaseAmbiguityCount();
> 				return new ParseNode(t.getLabel(), rest, AbstractParseNode.PARSENODE);
> 			} else {
> 				throw new FilterException(parser);
> 			}
> 		} else if (last.isParseNode()) {
> 			final Label other = parseTable.getLabel(((ParseNode) last).getLabel());
> 			if (prodLabel.equals(other)) {
> 				throw new FilterException(parser);
> 			}
> 		}
> 
> 		return t;
> 	}
> 
> 	private Label getProductionLabel(AbstractParseNode t) {
> 		if (t.isParseNode()) {
> 			return parseTable.getLabel(((ParseNode) t).getLabel());
> 		} else if (t instanceof ParseProductionNode) {
> 			return parseTable.getLabel(((ParseProductionNode) t).getProduction());
> 		}
> 		return null;
> 	}
> 
> 	private boolean hasRejectProd(AbstractParseNode t) {
> 		return t.isParseRejectNode();
> 	}
> 
> 	private AbstractParseNode filterAmbiguities(AbstractParseNode[] ambs) throws FilterException {
> 		// SG_FilterAmb
> 
> 		if(Tools.debugging) {
> 			Tools.debug("filterAmbiguities() - [", ambs.length, "]");
> 		}
> 
> 		List<AbstractParseNode> newAmbiguities = new ArrayList<AbstractParseNode>();
> 
> 		for (final AbstractParseNode amb : ambs) {
> 			final AbstractParseNode newAmb = filterTree(amb, true);
> 			if (newAmb != null && rejectedBranch == null) {
> 				newAmbiguities.add(newAmb);
> 			}
> 			rejectedBranch = null;
> 		}
> 
> 		if (newAmbiguities.size() > 1) {
> 			/* Handle ambiguities inside this ambiguity cluster */
> 			final List<AbstractParseNode> oldAmbiguities = new ArrayList<AbstractParseNode>(newAmbiguities);
> 			for (final AbstractParseNode amb : oldAmbiguities) {
> 				if (newAmbiguities.remove(amb)) {
> 					newAmbiguities = filterAmbiguityList(newAmbiguities, amb);
> 				}
> 			}
> 		}
> 
> 		if (newAmbiguities.isEmpty()) {
> 			// All alternatives were rejected;
> 			// the outer context should be rejected as well
> 			return rejectedBranch = ParseNode.createAmbNode(ambs);
> 		}
> 
> 		if (newAmbiguities.size() == 1) {
> 			return newAmbiguities.get(0);
> 		}
> 
> 		ambiguityManager.increaseAmbiguityCount();
> 		return ParseNode.createAmbNode(newAmbiguities.toArray(new AbstractParseNode[newAmbiguities.size()]));
> 	}
> 
> 	private List<AbstractParseNode> filterAmbiguityList(List<AbstractParseNode> ambs, AbstractParseNode t) {
> 		// SG_FilterAmbList
> 
> 		boolean keepT = true;
> 		final List<AbstractParseNode> r = new ArrayList<AbstractParseNode>();
> 
> 		if (ambs.isEmpty()) {
> 			r.add(t);
> 			return r;
> 		}
> 
> 		for (int i = 0, max = ambs.size(); i < max; i++) {
> 			final AbstractParseNode amb = ambs.get(i);
> 			switch (filter(t, amb)) {
> 			case FILTER_DRAW:
> 				r.add(amb);
> 				break;
> 			case FILTER_RIGHT_WINS:
> 				r.add(amb);
> 				keepT = false;
> 			}
> 		}
> 
> 		if (keepT) {
> 			r.add(t);
> 		}
> 
> 		return r;
> 	}
> 
> 	private int filter(AbstractParseNode left, AbstractParseNode right) {
> 		// SG_Filter(t0, t1)
> 
> 		if(Tools.debugging) {
> 			Tools.debug("filter()");
> 		}
> 
> 		if (left.equals(right)) {
> 			return FILTER_LEFT_WINS;
> 		}
> 
> 		/* UNDONE: direct eagerness filter seems to be disabled in reference SGLR
>         if (filterDirectPreference && parseTable.hasPrefersOrAvoids()) {
>             int r = filterOnDirectPrefers(left, right);
>             if (r != FILTER_DRAW)
>                 return r;
>         }
> 		 */
> 
> 		// like C-SGLR, we use indirect preference filtering if the direct one is enabled
> 		if (filterDirectPreference && parseTable.hasPrefersOrAvoids()) {
> 			final int r = filterOnIndirectPrefers(left, right);
> 			if (r != FILTER_DRAW) {
> 				return r;
> 			}
> 		}
> 
> 		if (filterPreferenceCount && parseTable.hasPrefersOrAvoids()) {
> 			final int r = filterOnPreferCount(left, right);
> 			if (r != FILTER_DRAW) {
> 				return r;
> 			}
> 		}
> 
> 		if (filterInjectionCount) {
> 			final int r = filterOnInjectionCount(left, right);
> 			if (r != FILTER_DRAW) {
> 				return r;
> 			}
> 		}
> 
> 		return filterPermissiveLiterals(left, right);
> 	}
> 
> 	private int filterPermissiveLiterals(AbstractParseNode left, AbstractParseNode right) {
> 		// Work-around for http://bugs.strategoxt.org/browse/SPI-5 (Permissive grammars introduce ambiguities for literals)
> 
> 		if (left.isParseNode() && right.isParseNode()) {
> 			final AbstractParseNode[] leftKids = ((ParseNode) left).kids;
> 			final AbstractParseNode[] rightKids = ((ParseNode) right).kids;
> 			if (leftKids.length > 0 && rightKids.length == 1) {
> 				if (leftKids[0] instanceof ParseProductionNode && rightKids[0].equals(left)) {
> 					return FILTER_LEFT_WINS;
> 				}
> 			}
> 		}
> 		return FILTER_DRAW;
> 	}
> 
> 	private int filterOnInjectionCount(AbstractParseNode left, AbstractParseNode right) {
> 
> 		if(Tools.debugging) {
> 			Tools.debug("filterOnInjectionCount()");
> 		}
> 
> 		ambiguityManager.increaseInjectionCount();
> 
> 		final int leftInjectionCount = countAllInjections(left);
> 		final int rightInjectionCount = countAllInjections(right);
> 
> 		if (leftInjectionCount != rightInjectionCount) {
> 			ambiguityManager.increaseInjectionFilterSucceededCount();
> 		}
> 
> 		if (leftInjectionCount > rightInjectionCount) {
> 			return FILTER_RIGHT_WINS;
> 		} else if (rightInjectionCount > leftInjectionCount) {
> 			return FILTER_LEFT_WINS;
> 		}
> 
> 		return FILTER_DRAW;
> 	}
> 
> 	private int countAllInjections(AbstractParseNode t) {
> 		// SG_CountAllInjectionsInTree
> 		// - ok
> 		if (t.isAmbNode()) {
> 			// Trick from forest.c
> 			return t.getChildren().length == 0 ? 0 : countAllInjections(t.getChildren()[0]);
> 		} else if (t.isParseNode()) {
> 			final int c = getProductionLabel(t).isInjection() ? 1 : 0;
> 			return c + countAllInjections(((ParseNode) t).kids);
> 		}
> 		return 0;
> 	}
> 
> 	private int countAllInjections(AbstractParseNode[] ls) {
> 		// SG_CountAllInjectionsInTree
> 		// - ok
> 		int r = 0;
> 		for (int i = 0, max = ls.length; i < max; i++) {
> 			r += countAllInjections(ls[i]);
> 		}
> 		return r;
> 	}
> 
> 	private int filterOnPreferCount(AbstractParseNode left, AbstractParseNode right) {
> 
> 		if(Tools.debugging) {
> 			Tools.debug("filterOnPreferCount()");
> 		}
> 
> 		ambiguityManager.increaseEagernessFilterCalledCount();
> 
> 		int r = FILTER_DRAW;
> 		if (parseTable.hasPrefers() || parseTable.hasAvoids()) {
> 			final int leftPreferCount = countPrefers(left);
> 			final int rightPreferCount = countPrefers(right);
> 			final int leftAvoidCount = countAvoids(left);
> 			final int rightAvoidCount = countAvoids(right);
> 
> 			if ((leftPreferCount > rightPreferCount && leftAvoidCount <= rightAvoidCount)
> 					|| (leftPreferCount == rightPreferCount && leftAvoidCount < rightAvoidCount)) {
> 				Tools.logger("Eagerness priority: ", left, " > ", right);
> 				r = FILTER_LEFT_WINS;
> 			}
> 
> 			if ((rightPreferCount > leftPreferCount && rightAvoidCount <= leftAvoidCount)
> 					|| (rightPreferCount == leftPreferCount && rightAvoidCount < leftAvoidCount)) {
> 				if (r != FILTER_DRAW) {
> 					Tools.logger("Symmetric eagerness priority: ", left, " == ", right);
> 					r = FILTER_DRAW;
> 				} else {
> 					Tools.logger("Eagerness priority: ", right, " > ", left);
> 					r = FILTER_RIGHT_WINS;
> 				}
> 			}
> 		}
> 
> 		if (r != FILTER_DRAW) {
> 			ambiguityManager.increaseEagernessFilterSucceededCount();
> 		}
> 
> 		return r;
> 	}
> 
> 	private int countPrefers(AbstractParseNode t) {
> 		// SG_CountPrefersInTree
> 		// - ok
> 		if (t.isAmbNode()) {
> 			return countPrefers(t.getChildren());
> 		} else if (t.isParseNode()) {
> 			final int type = getProductionType(t);
> 			if (type == ProductionType.PREFER) {
> 				return 1;
> 			} else if (type == ProductionType.AVOID) {
> 				return 0;
> 			}
> 			return countPrefers(((ParseNode) t).kids);
> 		}
> 		return 0;
> 	}
> 
> 	private int countPrefers(AbstractParseNode[] ls) {
> 		// SG_CountPrefersInTree
> 		// - ok
> 		int r = 0;
> 		for (final AbstractParseNode n : ls) {
> 			r += countPrefers(n);
> 		}
> 		return r;
> 	}
> 
> 	private int countAvoids(AbstractParseNode t) {
> 		// SG_CountAvoidsInTree
> 		// - ok
> 		if (t.isAmbNode()) {
> 			return countAvoids(t.getChildren());
> 		} else if (t.isParseNode()) {
> 			final int type = getProductionType(t);
> 			if (type == ProductionType.PREFER) {
> 				return 0;
> 			} else if (type == ProductionType.AVOID) {
> 				return 1;
> 			}
> 			return countAvoids(((ParseNode) t).kids);
> 		}
> 		return 0;
> 	}
> 
> 	private int countAvoids(AbstractParseNode[] ls) {
> 		// SG_CountAvoidsInTree
> 		// - ok
> 		int r = 0;
> 		for (final AbstractParseNode n : ls) {
> 			r += countAvoids(n);
> 		}
> 		return r;
> 	}
> 
> 	private int filterOnIndirectPrefers(AbstractParseNode left, AbstractParseNode right) {
> 		// SG_Indirect_Eagerness_Filter
> 
> 		if(Tools.debugging) {
> 			Tools.debug("filterOnIndirectPrefers()");
> 		}
> 
> 		if (left.isAmbNode() || right.isAmbNode()) {
> 			return FILTER_DRAW;
> 		}
> 
> 		if (!getLabel(left).equals(getLabel(right))) {
> 			return filterOnDirectPrefers(left, right);
> 		}
> 
> 		final ParseNode l = (ParseNode) left;
> 		final ParseNode r = (ParseNode) right;
> 
> 		final AbstractParseNode[] leftArgs = l.kids;
> 		final AbstractParseNode[] rightArgs = r.kids;
> 
> 		final int diffs = computeDistinctArguments(leftArgs, rightArgs);
> 
> 		if (diffs == 1) {
> 			for (int i = 0; i < leftArgs.length; i++) {
> 				final AbstractParseNode leftArg = leftArgs[i];
> 				final AbstractParseNode rightArg = rightArgs[i];
> 
> 				if (!leftArg.equals(rightArg)) {
> 					return filterOnIndirectPrefers(leftArg, rightArg);
> 				}
> 			}
> 
> 		}
> 		return FILTER_DRAW;
> 	}
> 
> 	private int filterOnDirectPrefers(AbstractParseNode left, AbstractParseNode right) {
> 		// SG_Direct_Eagerness_Filter
> 
> 		if(Tools.debugging) {
> 			Tools.debug("filterOnDirectPrefers()");
> 		}
> 
> 		// TODO: optimize - move up the jumpOverInjectionsModuloEagerness calls
> 		if (isLeftMoreEager(left, right)) {
> 			return FILTER_LEFT_WINS;
> 		}
> 		if (isLeftMoreEager(right, left)) {
> 			return FILTER_RIGHT_WINS;
> 		}
> 
> 		return FILTER_DRAW;
> 	}
> 
> 	private boolean isLeftMoreEager(AbstractParseNode left, AbstractParseNode right) {
> 		assert !(left.isAmbNode() || right.isAmbNode());
> 		if (isMoreEager(left, right)) {
> 			return true;
> 		}
> 
> 		final AbstractParseNode newLeft = jumpOverInjectionsModuloEagerness(left);
> 		final AbstractParseNode newRight = jumpOverInjectionsModuloEagerness(right);
> 
> 		if (newLeft.isParseNode() && newRight.isParseNode()) {
> 			return isMoreEager(newLeft, newRight);
> 		}
> 
> 		return false;
> 	}
> 
> 	private AbstractParseNode jumpOverInjectionsModuloEagerness(AbstractParseNode t) {
> 
> 		if(Tools.debugging) {
> 			Tools.debug("jumpOverInjectionsModuloEagerness()");
> 		}
> 
> 		final int prodType = getProductionType(t);
> 
> 		if (t.isParseNode() && prodType != ProductionType.PREFER
> 				&& prodType != ProductionType.AVOID) {
> 
> 			Label prod = getLabel(t);
> 
> 			while (prod.isInjection()) {
> 				t = ((ParseNode) t).kids[0];
> 
> 
> 				if (t.isParseNode()) {
> 					final int prodTypeX = getProductionType(t);
> 
> 					if (prodTypeX != ProductionType.PREFER
> 							&& prodTypeX != ProductionType.AVOID) {
> 						prod = getLabel(t);
> 						continue;
> 					}
> 				}
> 				return t;
> 			}
> 		}
> 		return t;
> 	}
> 
> 	private Label getLabel(AbstractParseNode t) {
> 		if (t.isParseNode()) {
> 			final ParseNode n = (ParseNode) t;
> 			return parseTable.getLabel(n.getLabel());
> 		} else if (t instanceof ParseProductionNode) {
> 			final ParseProductionNode n = (ParseProductionNode) t;
> 			return parseTable.getLabel(n.prod);
> 		}
> 		return null;
> 	}
> 
> 	private int getProductionType(AbstractParseNode t) {
> 		return getLabel(t).getAttributes().getType();
> 	}
> 
> 	private boolean isMoreEager(AbstractParseNode left, AbstractParseNode right) {
> 		final int leftLabel = ((ParseNode) left).getLabel();
> 		final int rightLabel = ((ParseNode) right).getLabel();
> 
> 		final Label leftProd = parseTable.getLabel(leftLabel);
> 		final Label rightProd = parseTable.getLabel(rightLabel);
> 
> 		if (leftProd.isMoreEager(rightProd)) {
> 			return true;
> 		}
> 
> 		return false;
> 	}
> 
> 	private int computeDistinctArguments(AbstractParseNode[] leftArgs, AbstractParseNode[] rightArgs) {
> 		// countDistinctArguments
> 		int r = 0;
> 		for (int i = 0; i < leftArgs.length; i++) {
> 			if (!leftArgs[i].equals(rightArgs[i])) {
> 				r++;
> 			}
> 		}
> 		return r;
> 	}
> 
> 	private boolean isCyclicTerm(AbstractParseNode t) {
> 
> 		ambiguityManager.dumpIndexTable();
> 
> 		final List<AbstractParseNode> cycles = computeCyclicTerm(t);
> 
> 		return cycles != null && cycles.size() > 0;
> 	}
> 
> 	private List<AbstractParseNode> computeCyclicTerm(AbstractParseNode t) {
> 		// FIXME rewrite to use HashMap and object id
> 		final PositionMap visited = new PositionMap(ambiguityManager.getMaxNumberOfAmbiguities());
> 
> 		ambiguityManager.resetAmbiguityCount();
> 
> 		return computeCyclicTerm(t, false, visited);
> 	}
> 
> 	private List<AbstractParseNode> computeCyclicTerm(AbstractParseNode t, boolean inAmbiguityCluster,
> 			PositionMap visited) {
> 
> 		if (Tools.debugging) {
> 			Tools.debug("computeCyclicTerm() - ", t);
> 		}
> 
> 		if (t instanceof ParseProductionNode) {
> 			if (Tools.debugging) {
> 				Tools.debug(" bumping");
> 			}
> 			return null;
> 		} else if (t.isParseNode()) {
> 			//Amb ambiguities = null;
> 			List<AbstractParseNode> cycle = null;
> 			//int clusterIndex;
> 			final ParseNode n = (ParseNode) t;
> 
> 			if (inAmbiguityCluster) {
> 				cycle = computeCyclicTerm(n.kids, false, visited);
> 			} else {
> 				/*
>                 if (ambiguityManager.isInputAmbiguousAt(parseTreePosition)) {
>                     ambiguityManager.increaseAmbiguityCount();
>                     clusterIndex = ambiguityManager.getClusterIndex(t, parseTreePosition);
>                     if (SGLR.isDebugging()) {
>                         Tools.debug(" - clusterIndex : ", clusterIndex);
>                     }
>                     if (markMap.isMarked(clusterIndex)) {
>                         return new ArrayList<IParseNode>();
>                     }
>                     ambiguities = ambiguityManager.getClusterOnIndex(clusterIndex);
>                 } else {
>                     clusterIndex = -1;
>                 }*/
> 
> 				throw new NotImplementedException();
> 				/*
>                 if (ambiguities == null) {
>                     cycle = computeCyclicTerm(((ParseNode) t).getKids(), false, visited);
>                 } else {
>                     int length = visited.getValue(clusterIndex);
>                     int savePos = parseTreePosition;
> 
>                     if (length == -1) {
>                         //markMap.mark(clusterIndex);
>                         cycle = computeCyclicTermInAmbiguityCluster(ambiguities, visited);
>                         visited.put(clusterIndex, parseTreePosition - savePos);
>                         //markMap.unmark(clusterIndex);
>                     } else {
>                         parseTreePosition += length;
>                     }
>                 }
> 				 */
> 			}
> 			return cycle;
> 		} else {
> 			throw new FatalException();
> 		}
> 	}
> 
> 	/*
>     private List<IParseNode> computeCyclicTermInAmbiguityCluster(Amb ambiguities,
>             PositionMap visited) {
> 
> 
>         List<IParseNode> ambs = ambiguities.getAlternatives();
>         for (int i = 0, max = ambs.size(); i < max; i++) {
>             IParseNode amb = ambs.get(i);
>             List<IParseNode> cycle = computeCyclicTerm(amb, true, visited);
>             if (cycle != null)
>                 return cycle;
1069,1370c1315
<       }
<     }
< 
<     if (r != FILTER_DRAW) {
<       ambiguityManager.increaseEagernessFilterSucceededCount();
<     }
< 
<     return r;
<   }
< 
<   private int countPrefers(AbstractParseNode t) {
<     // SG_CountPrefersInTree
<     // - ok
<     if (t.isAmbNode()) {
<       return countPrefers(t.getChildren());
<     } else if (t.isParseNode()) {
<       final int type = getProductionType(t);
<       if (type == ProductionType.PREFER) {
<         return 1;
<       } else if (type == ProductionType.AVOID) {
<         return 0;
<       }
<       return countPrefers(((ParseNode) t).kids);
<     }
<     return 0;
<   }
< 
<   private int countPrefers(AbstractParseNode[] ls) {
<     // SG_CountPrefersInTree
<     // - ok
<     int r = 0;
<     for (final AbstractParseNode n : ls) {
<       r += countPrefers(n);
<     }
<     return r;
<   }
< 
<   private int countAvoids(AbstractParseNode t) {
<     // SG_CountAvoidsInTree
<     // - ok
<     if (t.isAmbNode()) {
<       return countAvoids(t.getChildren());
<     } else if (t.isParseNode()) {
<       final int type = getProductionType(t);
<       if (type == ProductionType.PREFER) {
<         return 0;
<       } else if (type == ProductionType.AVOID) {
<         return 1;
<       }
<       return countAvoids(((ParseNode) t).kids);
<     }
<     return 0;
<   }
< 
<   private int countAvoids(AbstractParseNode[] ls) {
<     // SG_CountAvoidsInTree
<     // - ok
<     int r = 0;
<     for (final AbstractParseNode n : ls) {
<       r += countAvoids(n);
<     }
<     return r;
<   }
< 
<   private int filterOnIndirectPrefers(AbstractParseNode left,
<       AbstractParseNode right) {
<     // SG_Indirect_Eagerness_Filter
< 
<     if (Tools.debugging) {
<       Tools.debug("filterOnIndirectPrefers()");
<     }
< 
<     if (left.isAmbNode() || right.isAmbNode()) {
<       return FILTER_DRAW;
<     }
< 
<     if (!getLabel(left).equals(getLabel(right))) {
<       return filterOnDirectPrefers(left, right);
<     }
< 
<     final ParseNode l = (ParseNode) left;
<     final ParseNode r = (ParseNode) right;
< 
<     final AbstractParseNode[] leftArgs = l.kids;
<     final AbstractParseNode[] rightArgs = r.kids;
< 
<     final int diffs = computeDistinctArguments(leftArgs, rightArgs);
< 
<     if (diffs == 1) {
<       for (int i = 0; i < leftArgs.length; i++) {
<         final AbstractParseNode leftArg = leftArgs[i];
<         final AbstractParseNode rightArg = rightArgs[i];
< 
<         if (!leftArg.equals(rightArg)) {
<           return filterOnIndirectPrefers(leftArg, rightArg);
<         }
<       }
< 
<     }
<     return FILTER_DRAW;
<   }
< 
<   private int filterOnDirectPrefers(AbstractParseNode left,
<       AbstractParseNode right) {
<     // SG_Direct_Eagerness_Filter
< 
<     if (Tools.debugging) {
<       Tools.debug("filterOnDirectPrefers()");
<     }
< 
<     // TODO: optimize - move up the jumpOverInjectionsModuloEagerness calls
<     if (isLeftMoreEager(left, right)) {
<       return FILTER_LEFT_WINS;
<     }
<     if (isLeftMoreEager(right, left)) {
<       return FILTER_RIGHT_WINS;
<     }
< 
<     return FILTER_DRAW;
<   }
< 
<   private boolean isLeftMoreEager(AbstractParseNode left,
<       AbstractParseNode right) {
<     assert !(left.isAmbNode() || right.isAmbNode());
<     if (isMoreEager(left, right)) {
<       return true;
<     }
< 
<     final AbstractParseNode newLeft = jumpOverInjectionsModuloEagerness(left);
<     final AbstractParseNode newRight = jumpOverInjectionsModuloEagerness(right);
< 
<     if (newLeft.isParseNode() && newRight.isParseNode()) {
<       return isMoreEager(newLeft, newRight);
<     }
< 
<     return false;
<   }
< 
<   private AbstractParseNode jumpOverInjectionsModuloEagerness(
<       AbstractParseNode t) {
< 
<     if (Tools.debugging) {
<       Tools.debug("jumpOverInjectionsModuloEagerness()");
<     }
< 
<     final int prodType = getProductionType(t);
< 
<     if (t.isParseNode() && prodType != ProductionType.PREFER
<         && prodType != ProductionType.AVOID) {
< 
<       Label prod = getLabel(t);
< 
<       while (prod.isInjection()) {
<         t = ((ParseNode) t).kids[0];
< 
<         if (t.isParseNode()) {
<           final int prodTypeX = getProductionType(t);
< 
<           if (prodTypeX != ProductionType.PREFER
<               && prodTypeX != ProductionType.AVOID) {
<             prod = getLabel(t);
<             continue;
<           }
<         }
<         return t;
<       }
<     }
<     return t;
<   }
< 
<   private Label getLabel(AbstractParseNode t) {
<     if (t.isParseNode()) {
<       final ParseNode n = (ParseNode) t;
<       return parseTable.getLabel(n.getLabel());
<     } else if (t instanceof ParseProductionNode) {
<       final ParseProductionNode n = (ParseProductionNode) t;
<       return parseTable.getLabel(n.prod);
<     }
<     return null;
<   }
< 
<   private int getProductionType(AbstractParseNode t) {
<     return getLabel(t).getAttributes().getType();
<   }
< 
<   private boolean isMoreEager(AbstractParseNode left, AbstractParseNode right) {
<     final int leftLabel = ((ParseNode) left).getLabel();
<     final int rightLabel = ((ParseNode) right).getLabel();
< 
<     final Label leftProd = parseTable.getLabel(leftLabel);
<     final Label rightProd = parseTable.getLabel(rightLabel);
< 
<     if (leftProd.isMoreEager(rightProd)) {
<       return true;
<     }
< 
<     return false;
<   }
< 
<   private int computeDistinctArguments(AbstractParseNode[] leftArgs,
<       AbstractParseNode[] rightArgs) {
<     // countDistinctArguments
<     int r = 0;
<     for (int i = 0; i < leftArgs.length; i++) {
<       if (!leftArgs[i].equals(rightArgs[i])) {
<         r++;
<       }
<     }
<     return r;
<   }
< 
<   private boolean isCyclicTerm(AbstractParseNode t) {
< 
<     ambiguityManager.dumpIndexTable();
< 
<     final List<AbstractParseNode> cycles = computeCyclicTerm(t);
< 
<     return cycles != null && cycles.size() > 0;
<   }
< 
<   private List<AbstractParseNode> computeCyclicTerm(AbstractParseNode t) {
<     // FIXME rewrite to use HashMap and object id
<     final PositionMap visited = new PositionMap(
<         ambiguityManager.getMaxNumberOfAmbiguities());
< 
<     ambiguityCount += ambiguityManager.getAmbiguitiesCount();
<     ambiguityManager.resetAmbiguityCount();
< 
<     return computeCyclicTerm(t, false, visited);
<   }
< 
<   private List<AbstractParseNode> computeCyclicTerm(AbstractParseNode t,
<       boolean inAmbiguityCluster, PositionMap visited) {
< 
<     if (Tools.debugging) {
<       Tools.debug("computeCyclicTerm() - ", t);
<     }
< 
<     if (t instanceof ParseProductionNode) {
<       if (Tools.debugging) {
<         Tools.debug(" bumping");
<       }
<       return null;
<     } else if (t.isParseNode()) {
<       // Amb ambiguities = null;
<       List<AbstractParseNode> cycle = null;
<       // int clusterIndex;
<       final ParseNode n = (ParseNode) t;
< 
<       if (inAmbiguityCluster) {
<         cycle = computeCyclicTerm(n.kids, false, visited);
<       } else {
<         /*
<          * if (ambiguityManager.isInputAmbiguousAt(parseTreePosition)) {
<          * ambiguityManager.increaseAmbiguityCount(); clusterIndex =
<          * ambiguityManager.getClusterIndex(t, parseTreePosition); if
<          * (SGLR.isDebugging()) { Tools.debug(" - clusterIndex : ",
<          * clusterIndex); } if (markMap.isMarked(clusterIndex)) { return new
<          * ArrayList<IParseNode>(); } ambiguities =
<          * ambiguityManager.getClusterOnIndex(clusterIndex); } else {
<          * clusterIndex = -1; }
<          */
< 
<         throw new NotImplementedException();
<         /*
<          * if (ambiguities == null) { cycle = computeCyclicTerm(((ParseNode)
<          * t).getKids(), false, visited); } else { int length =
<          * visited.getValue(clusterIndex); int savePos = parseTreePosition;
<          * 
<          * if (length == -1) { //markMap.mark(clusterIndex); cycle =
<          * computeCyclicTermInAmbiguityCluster(ambiguities, visited);
<          * visited.put(clusterIndex, parseTreePosition - savePos);
<          * //markMap.unmark(clusterIndex); } else { parseTreePosition += length;
<          * } }
<          */
<       }
<       return cycle;
<     } else {
<       throw new FatalException();
<     }
<   }
< 
<   /*
<    * private List<IParseNode> computeCyclicTermInAmbiguityCluster(Amb
<    * ambiguities, PositionMap visited) {
<    * 
<    * 
<    * List<IParseNode> ambs = ambiguities.getAlternatives(); for (int i = 0, max
<    * = ambs.size(); i < max; i++) { IParseNode amb = ambs.get(i);
<    * List<IParseNode> cycle = computeCyclicTerm(amb, true, visited); if (cycle
<    * != null) return cycle; } return null; }
<    */
< 
<   private List<AbstractParseNode> computeCyclicTerm(AbstractParseNode[] kids,
<       boolean b, PositionMap visited) {
< 
<     for (int i = 0, max = kids.length; i < max; i++) {
<       final List<AbstractParseNode> cycle = computeCyclicTerm(kids[i], false,
<           visited);
<       if (cycle != null) {
<         return cycle;
<       }
---
>         return null;
1372,1373c1317
<     return null;
<   }
---
> 	 */
1375,1381c1319
<   private List<int[]> getLongestMatchPositions(AbstractParseNode n) {
<     if (n.isAmbNode()) {
<       List<int[]> pos1 = getLongestMatchPositions(n.getChildren()[0]);
<       List<int[]> pos2 = getLongestMatchPositions(n.getChildren()[1]);
<       assert pos1.size() == pos2.size();
<       return pos1;
<     }
---
> 	private List<AbstractParseNode> computeCyclicTerm(AbstractParseNode[] kids, boolean b, PositionMap visited) {
1383,1399c1321,1328
<     LinkedList<AbstractParseNode> nodes = new LinkedList<AbstractParseNode>();
<     nodes.push(n);
<     
<     ArrayList<int[]> positions = new ArrayList<int[]>();
<     
<     while (!nodes.isEmpty()) {
<       n = nodes.pop();
<       
<       if (n.isParseProductionNode())
<         continue;
<             
<       if (!n.isAmbNode() && parseTable.getLabel(n.getLabel()).getAttributes().isLongestMatch())
<         positions.add(new int[]{n.getLine(), n.getColumn(), n.getLast().getLine(), n.getLast().getColumn()});
<       
<       for (int i = n.getChildren().length - 1; i >= 0; i--)
<         nodes.push(n.getChildren()[i]);
<     }
---
> 		for (int i = 0, max = kids.length; i < max; i++) {
> 			final List<AbstractParseNode> cycle = computeCyclicTerm(kids[i], false, visited);
> 			if (cycle != null) {
> 				return cycle;
> 			}
> 		}
> 		return null;
> 	}
1401,1487d1329
<     return positions;
<   }
<   
<   private class LongestMatchIterator implements Iterator<int[]> {
<     private int[] next = null;
<     private boolean computedNext = false;
<     private LinkedList<AbstractParseNode> nodes = new LinkedList<AbstractParseNode>();
<     
<     public LongestMatchIterator(AbstractParseNode n) {
<       nodes.push(n);
<     }
<     
<     @Override
<     public void remove() {
<       throw new UnsupportedOperationException();
<     }
<     
<     @Override
<     public int[] next() {
<       if (!computedNext)
<         computeNext();
<       int[] res = next;
<       computedNext = false;
<       next = null;
<       return res;
<     }
<     
<     @Override
<     public boolean hasNext() {
<       if (!computedNext)
<         computeNext();
<       return next != null;
<     }
<     
<     private void computeNext() {
<       while (!computedNext && !nodes.isEmpty()) {
<         AbstractParseNode n = nodes.pop();
<         
<         if (n.isParseProductionNode())
<           continue;
<               
<         if (!n.isLayout())
<           for (int i = n.getChildren().length - 1; i >= 0; i--)
<             nodes.push(n.getChildren()[i]);
< 
<         if (!n.isAmbNode() && parseTable.getLabel(n.getLabel()).getAttributes().isLongestMatch()) {
<           next = new int[]{n.getLine(), n.getColumn(), n.getLast().getLine(), n.getLast().getColumn()};
<           computedNext = true;
<         }
<       }
<     }
<   }
<   
<   private Iterator<int[]> getLongestMatchIterator(AbstractParseNode n) {
<     if (n.isAmbNode()) {
<       List<int[]> pos1 = getLongestMatchPositions(n.getChildren()[0]);
<       List<int[]> pos2 = getLongestMatchPositions(n.getChildren()[1]);
<       assert pos1.size() == pos2.size();
<       return pos1.iterator();
<     }
< 
<     return new LongestMatchIterator(n); 
<   }
<   
<   private int filterLongestMatch(AbstractParseNode left, AbstractParseNode right) {
<     Iterator<int[]> leftPositions = getLongestMatchIterator(left);
<     Iterator<int[]> rightPositions = getLongestMatchIterator(right);
<     
<     while (leftPositions.hasNext() && rightPositions.hasNext()) {
<       int[] leftPosition = leftPositions.next();
<       int[] rightPosition = rightPositions.next();
< 
<       if (leftPosition[0] == rightPosition[0] && leftPosition[1] == rightPosition[1]) {
<         if (leftPosition[2] > rightPosition[2] || leftPosition[2] == rightPosition[2] && leftPosition[3] > rightPosition[3])
<           return FILTER_LEFT_WINS;
<         else if (leftPosition[2] < rightPosition[2] || leftPosition[2] == rightPosition[2] && leftPosition[3] < rightPosition[3])
<           return FILTER_RIGHT_WINS;
<       }
<       else
<         System.out.println("mismatching start");
<     }
<     
<     assert !leftPositions.hasNext() && !rightPositions.hasNext();
<     
<     return FILTER_DRAW;
<   }
<   
Only in /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client: FineGrainedOnRegion.java
Only in src/org/spoofax/jsglr/client: FineGrainedRecovery.java
Only in src/org/spoofax/jsglr/client: FineGrainedSetting.java
diff -r --exclude=.svn /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/Frame.java src/org/spoofax/jsglr/client/Frame.java
4,5c4,5
<  * Copyright (c) 2005, Karl Trygve Kalleberg <karltk near strategoxt.org>
<  * 
---
>  * Copyright (c) 2005-2011, Karl Trygve Kalleberg <karltk near strategoxt dot org>
>  *
12d11
< import java.util.List;
18c17
<     
---
> 
20c19
<             
---
> 
28,29c27,28
<     
<     
---
> 
> 
33c32
<     
---
> 
41c40,41
<         framesCreated +=1; //MJ: for testing 
---
>         framesCreated +=1; //MJ: for testing
> 
48c48
<         
---
> 
63,68d62
<     
<     public Link peekLink() {
<       if (stepsCount == 0)
<         return null;
<       return steps[0];
<   }
70,75c64
<   public Link[] peekLinks() {
<     return steps;
<   }
< 
<     
<     public void findAllPaths(PooledPathList pool, int arity) throws InterruptedException {
---
>     public void findAllPaths(PooledPathList pool, int arity) {
79,82c68
<     private void doComputePathsToRoot(PooledPathList pool, Path node, int arity, int parentCount, int length) throws InterruptedException {
<         
<       if (Thread.currentThread().isInterrupted())
<         throw new InterruptedException();
---
>     private void doComputePathsToRoot(PooledPathList pool, Path node, int arity, int parentCount, int length) {
93c79
<         } else { 
---
>         } else {
96c82
<                 
---
> 
115c101
<         
---
> 
120c106
<         
---
> 
122,123c108,109
<     }   
<     
---
>     }
> 
131c117
<         }        
---
>         }
133,134c119,120
<     }   
<     
---
>     }
> 
137,138c123,124
<     
<     public Link addLink(Frame st0, AbstractParseNode n, int length, int line, int column) {
---
> 
>     public Link addLink(Frame st0, AbstractParseNode n, int length) {
145d130
<         
147c132
<         return steps[stepsCount++] = new Link(st0, n, length, line, column); 
---
>         return steps[stepsCount++] = new Link(st0, n, length);
149c134
<     
---
> 
157d141
<         
159c143
<         return steps[stepsCount++] = ln; 
---
>         return steps[stepsCount++] = ln;
161c145
<     
---
> 
236c220
<     public void findLimitedPaths(PooledPathList pool, int arity, Link l) throws InterruptedException {
---
>     public void findLimitedPaths(PooledPathList pool, int arity, Link l) {
241c225
<         if(findLink(arity, l)) { 
---
>         if(findLink(arity, l)) {
243c227
<         } 
---
>         }
260c244
<         
---
> 
281,284c265
<       boolean seen, int arity, int parentCount, int length) throws InterruptedException {
<         if (Thread.currentThread().isInterrupted())
<           throw new InterruptedException();
<       
---
>       boolean seen, int arity, int parentCount, int length) {
315,316c296,297
<     
<     //mj debug info function
---
> 
>     /*mj debug info function
322,324c303,305
<                 result = steps[i].recoverCount;
<             result = Math.min(result, steps[i].recoverCount);
<             }            
---
>                 result = steps[i].recoverWeight;
>             result = Math.min(result, steps[i].recoverWeight);
>             }
328,329c309,310
<     
<   //mj debug info function
---
> 
>     //mj debug info function
341,343c322,324
<             if(ln.recoverCount ==0 || (avoidFree==false)) {
<                 if(ln.recoverCount ==0)
<                     childColl= ln.parent.getStackPaths(" - "+front, avoidFree); 
---
>             if(ln.recoverWeight ==0 || (avoidFree==false)) {
>                 if(ln.recoverWeight ==0)
>                     childColl= ln.parent.getStackPaths(" - "+front, avoidFree);
345c326
<                     String frnt = "-$"+ ln.recoverCount +"$-" + front;
---
>                     String frnt = "-$"+ ln.recoverWeight +"$-" + front;
349,350c330,331
<             }            
<         }            
---
>             }
>         }
358c339
<     }
---
>     }*/
diff -r --exclude=.svn /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/IRecoveryParser.java src/org/spoofax/jsglr/client/IRecoveryParser.java
3d2
< 
diff -r --exclude=.svn /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/IndentInfo.java src/org/spoofax/jsglr/client/IndentInfo.java
65c65
<     public int maxReduceLength() throws InterruptedException {
---
>     public int maxReduceLength() {
86c86
<     public int structureStartPosition() throws InterruptedException
---
>     public int structureStartPosition()
91c91
<     public Link getReductionLink() throws InterruptedException {
---
>     public Link getReductionLink() {
diff -r --exclude=.svn /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/IndentTokenizer.java src/org/spoofax/jsglr/client/IndentTokenizer.java
61c61
<     public void handleIndentShifts(SGLR parser) throws IOException, ParseException, InterruptedException
---
>     public void handleIndentShifts(SGLR parser) throws IOException, ParseException
73c73
<             IOException, InterruptedException {
---
>             IOException {
diff -r --exclude=.svn /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/IndentationHandler.java src/org/spoofax/jsglr/client/IndentationHandler.java
4d3
< 
Only in src/org/spoofax/jsglr/client: IntegratedRecoverySettings.java
diff -r --exclude=.svn /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/Label.java src/org/spoofax/jsglr/client/Label.java
13,14d12
< import org.spoofax.interpreter.terms.IStrategoTerm;
< import org.spoofax.terms.Term;
24,25d21
<     private Boolean isLayout;
<     //private final boolean isNewlineEnforcer;
47a44,47
>     
>     public boolean isCompletionProduction() {
>         return productionAttributes.isCompletionProduction();
>     }
74,109d73
< 
<     
<     
<     public boolean isLayout() {
<       if (isLayout != null)
<         return isLayout;
<       
<       IStrategoTerm t = prod.getSubterm(1);
<       
<       while (true) {
<         if (t.getTermType() != IStrategoTerm.APPL) {
<           isLayout = false;
<           break;
<         }
<         
<         IStrategoAppl app = (IStrategoAppl) t;
<         
<         if (Term.hasConstructor(app, "layout")) {
<           isLayout = true;
<           break;
<         }
<         
<         if (app.getSubtermCount() == 1 &&
<             (Term.hasConstructor(app, "cf") ||
<              Term.hasConstructor(app, "lex") ||
<              Term.hasConstructor(app, "opt") ||
<              Term.hasConstructor(app, "iter")))
<           t = app.getSubterm(0);
<         else {
<           isLayout = false;
<           break;
<         }
<       }
<       
<       return isLayout;
<     }
diff -r --exclude=.svn /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/Link.java src/org/spoofax/jsglr/client/Link.java
26,29c26,28
<     private int line;
<     private int column;
<     
<     public int recoverCount;
---
>     public int recoverWeight; //Weighted count used for disambiguation: Deletions are more expensive then Insertions
> 
>     public int recoverCount; //number of recover actions (used for cutting branches and error analysis)
31c30
<     public Link(Frame destination, AbstractParseNode t, int length, int line, int column) {
---
>     public Link(Frame destination, AbstractParseNode t, int length) {
36,38c35,36
<         this.line = line;
<         this.column = column;
<         recoverCount =0;
---
>         recoverWeight =0;
>         recoverCount = 0;
62,69d59
<     
<     public int getLine() {
<       return line;
<     }
< 
<     public int getColumn() {
<       return column;
<     }
diff -r --exclude=.svn /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/Measures.java src/org/spoofax/jsglr/client/Measures.java
3d2
< 
165c164
<             proParseCount = (int)Math.round((m.getParseCount()*1.0/base.getParseCount())*100);
---
>             proParseCount = (int)Math.round((Measures.getParseCount()*1.0/Measures.getParseCount())*100);
diff -r --exclude=.svn /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/NewStructureSkipper.java src/org/spoofax/jsglr/client/NewStructureSkipper.java
244,245c244
<         IndentInfo endSkip=IndentInfo.cloneIndentInfo(getHistory().getLine(indexEnd));
<         if(indexStart<0)
---
>         if(indexStart<0 || indexEnd > getHistory().getIndexLastLine())
246a246
>         IndentInfo endSkip=IndentInfo.cloneIndentInfo(getHistory().getLine(indexEnd));
409c409
<         int indexHistoryLines=startLineIndex;
---
>         int indexHistoryLines=startLineIndex-1;
411d410
<             indexHistoryLines-=1;            
423a423
>             indexHistoryLines-=1;            
457c457
<         if(index<=getHistory().getIndexLastLine()){
---
>         if(0 <= index && index<=getHistory().getIndexLastLine()){
diff -r --exclude=.svn /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/ParseNode.java src/org/spoofax/jsglr/client/ParseNode.java
2d1
< 
21a21,22
> 	
> 	private static final int AMB_LABEL = -1;
23,27c24
<   private static final int AMB_LABEL = -1;
< 
<   private int label;
< 
<   AbstractParseNode[] kids;
---
>     private int label;
29,33c26,28
<   private boolean isParseProductionChain; // should be set only after parsing
< 
<   private boolean isSetPPC;
< 
<   private int nodeType;
---
>     AbstractParseNode[] kids;
>     
>     private boolean isParseProductionChain; //should be set only after parsing 
35,40c30,32
<   private int cachedHashCode; // should be set only after parsing
<   
<   private AbstractParseNode left;
<   
<   private final boolean isLayout;
<   private final boolean isIgnoreLayout;
---
>     private boolean isSetPPC;
>     
>     private int nodeType;
42,45c34
<   @Override
<   public int getLabel() {
<     return label;
<   }
---
>     private int cachedHashCode; //should be set only after parsing 
47,55c36,49
<   public ParseNode(int label, AbstractParseNode[] kids, int type, int line, int column, boolean isLayout, boolean isIgnoreLayout) {
<     super(line, column);
<     this.isLayout = isLayout;
<     this.isIgnoreLayout = isIgnoreLayout;
<     setFields(label, kids, type);
<     if (type == AbstractParseNode.AMBIGUITY) {
<       this.isParseProductionChain = false;
<       this.isSetPPC = true;
<       assert this.label == AMB_LABEL;
---
>     @Override
> 	public int getLabel() {
>     	if(isAmbNode() || label == AMB_LABEL)
>     		throw new UnsupportedOperationException();
>     	return label;
>     }
> 
>     public ParseNode(int label, AbstractParseNode[] kids, int type) {
>     	setFields(label, kids, type);
>     	if(type == AbstractParseNode.AMBIGUITY){
>         	this.isParseProductionChain=false;
>         	this.isSetPPC=true;
>         	assert this.label == AMB_LABEL;
>     	}
57,63c51,231
<   }
< 
<   public static ParseNode createAmbNode(AbstractParseNode... kids) {
<     assert kids.length > 0;
< 
<     int line = kids[0].getLine();
<     int column = kids[0].getColumn();
---
>     
>     public static ParseNode createAmbNode(AbstractParseNode... kids){
>     	ParseNode amb = new ParseNode(AMB_LABEL, kids, AbstractParseNode.AMBIGUITY);
>     	return amb;
>     }
> 
> 	private void setFields(int label, AbstractParseNode[] kids, int type) {
> 		assert (type!=AbstractParseNode.AMBIGUITY || (label==AMB_LABEL));
> 		this.nodeType = type;
>         this.label = label;
>         this.kids = kids;
>         this.isParseProductionChain = false;
>         this.isSetPPC=false;
>  	}
> 	
> 	@Override
> 	public void reject() {
> 		// FIXME: this might not work if the current node is an AMB
> 		nodeType = REJECT;
> 	}
> 	
> 	public void makeAmbiguity(AbstractParseNode pn){
> 		//if (isAmbNode()) {
> 		//	if (isInAmbiguityCluster(pn)) return;
> 		//	AbstractParseNode[] newKids = new AbstractParseNode[kids.length + 1];
> 		//	System.arraycopy(kids, 0, newKids, 0, kids.length);
> 		//	newKids[newKids.length - 1] = pn;
> 		//	kids = newKids;
> 		//
> 		//	if(pn instanceof ParseNode)
> 		//		((ParseNode) pn).replaceCycle(this, null);
> 		//} else {
> 			if (this == pn || (isAmbNode() && isInAmbiguityCluster(pn)))
> 				return;
> 			ParseNode left = new ParseNode(this.label, this.kids, this.nodeType); 
> 			setFields(AMB_LABEL, new AbstractParseNode[] { left, pn }, AbstractParseNode.AMBIGUITY);
> 
> 			if(pn instanceof ParseNode)
> 				((ParseNode) pn).replaceCycle(this, left);
> 		//}
> 		
> 		assert(this.cachedHashCode == NO_HASH_CODE) : "Hashcode should not be cached during parsing because descendant nodes may change";
> 		assert(!this.isParseProductionChain) : "PPC is not set to true during parsing because descendents may change";
> 	}
> 
> 	private boolean isInAmbiguityCluster(AbstractParseNode pn) {
> 		for (AbstractParseNode existing : kids) {
> 			if (pn == existing) {
> 				return true;
> 			} else if (existing.isAmbNode()) {
> 				if (((ParseNode) existing).isInAmbiguityCluster(pn))
> 					return true;
> 			}
> 		}
> 		return false;
> 	}
> 	
> 	private void replaceCycle(ParseNode before, ParseNode after) {
> 		//only reductions for current char (right chain) are inspected
> 		// XXX: is that assumption correct? what about epsylon productions that consume no chars?
> 		if(isAmbNode()) { // all kids relate to current char
> 			for (int i = 0; i < kids.length; i++)
> 				replaceDescendantAt(before, after, i);			
> 		} else if(kids.length > 0 ){ 
> 			replaceDescendantAt(before, after, kids.length-1);			
> 		}
> 	}
> 
> 	private void replaceDescendantAt(ParseNode before, ParseNode after, int index) {
> 		AbstractParseNode kid = kids[index];
> 		if(kid==before){
> 			kids[index] = after == null ? new CycleParseNode(before) : after; 
> 			return; //no further inspection needed since cycles should not occur
> 		}
> 		else if(kid instanceof ParseNode){
> 			((ParseNode)kid).replaceCycle(before, after);
> 		}
> 	}
> 	    
>     @Override
> 	public boolean isParseProductionChain() {
>     	//REMARK: works because PPC property is not set during parsing, so descendants will not change
> 		// assert isParseProductionChain == calculateIsParseProdChain(kids);
>     	if(!isSetPPC)
>     		initParseProductionChain();
> 		return isParseProductionChain;
> 	}
>     
>     /**
>      * Initialize the {@link #isParseProductionChain} method
>      * for this node and any candidate chain nodes below it,
>      * without using recursion (which would potentially
>      * lead to a stack overflow).
>      */
>     private void initParseProductionChain() {
>     	AbstractParseNode deepest = getDeepestNonChainNode();
>     	if (deepest == this) { // fast path
>     		isSetPPC = true;
>     		isParseProductionChain = false;
>     	} else {
>     		setParseProductionChainUpTo(deepest == null, deepest);
>     	}
>     }
> 	
> 	/**
> 	 * Find the deepest parse node that is clearly not a 
> 	 * parse production chain node.
> 	 *
> 	 * @see #isParseProductionChain
> 	 */
>     private AbstractParseNode getDeepestNonChainNode() {
> 		AbstractParseNode current = this;
> 		for (;;) {
> 			AbstractParseNode[] kids = current.getChildren();
> 			switch (kids.length) {
> 				case 2:
> 					if (current instanceof ParseNode) {
> 						if (((ParseNode) current).isSetPPC)
> 							return current.isParseProductionChain() ? null : current;
> 					}
> 					if (!kids[0].isParseProductionNode())
> 						return kids[0];
> 					current = kids[1]; 
> 					break;
> 				case 1:
> 					current = kids[0];
> 					break;
> 				case 0:
> 					return current.isParseProductionNode() ? null : current;
> 				default:
> 					return current;
> 			}
> 		}
> 	}
> 	
> 	private void setParseProductionChainUpTo(boolean value, AbstractParseNode end) {
> 		AbstractParseNode current = this;
> 		AbstractParseNode next = this;
> 		do {
> 			current = next;
> 			ParseNode parseCurrent = null;
> 			if (current instanceof ParseNode)
> 				parseCurrent = (ParseNode) current;
> 			if (parseCurrent == null) {
> 				assert current.isCycle() || current.isParseProductionNode();
> 				return;
> 			}
> 			parseCurrent.isParseProductionChain = value;
> 			parseCurrent.isSetPPC = true;
> 			AbstractParseNode[] kids = parseCurrent.kids;
> 			switch (kids.length) {
> 				case 2:
> 					next = kids[1];
> 					break;
> 				case 1:
> 					next = kids[0];
> 					break;
> 				default:
> 					return;
> 			}
> 		} while (current != end);
> 	}
> 
> 	@Override 
>     public Object toTreeTopdown(TopdownTreeBuilder builder) {
>     	if(isAmbNode())
>         	return builder.buildTreeAmb(this);
>     	return builder.buildTreeNode(this);
>     }
> 
>     //TODO: refactor
>     @Override 
> 	public Object toTreeBottomup(BottomupTreeBuilder builder) {
>     	if(isAmbNode()){
>     		return toTreeBottomupAmb(builder);
>     	}
>     	builder.visitLabel(label);
>         ArrayList<Object> subtrees = new ArrayList<Object>(kids.length);
>         for (int i = 0; i < kids.length; i++) {
>         	subtrees.add(kids[i].toTreeBottomup(builder));
>         }
65,67c233,235
<     for (int i = 1; i < kids.length; i++) {
<       assert kids[i].getLine() == line;
<       assert kids[i].getColumn() == column;
---
>         Object result = builder.buildNode(label, subtrees);
>         builder.endVisitLabel(label);
> 		return result;
69,80d236
< 
<     ParseNode amb = new ParseNode(AMB_LABEL, kids, AbstractParseNode.AMBIGUITY, line, column, kids[0].isLayout(), kids[0].isIgnoreLayout());
<     return amb;
<   }
< 
<   private void setFields(int label, AbstractParseNode[] kids, int type) {
<     assert (type != AbstractParseNode.AMBIGUITY || (label == AMB_LABEL));
<     this.nodeType = type;
<     this.label = label;
<     this.kids = kids;
<     this.isParseProductionChain = false;
<     this.isSetPPC = false;
82,138c238,293
<     for (AbstractParseNode kid : kids)
<       if (!kid.isLayout() && !kid.isEmpty() && !kid.isIgnoreLayout()) {
<         if (kid.getLine() > getLine() && (left == null || kid.getColumn() < left.getColumn()))
<           left = kid;
<         AbstractParseNode kidLeft = kid.getLeft();
<         if (kidLeft != null && 
<             kidLeft.getLine() > getLine() &&
<             (left == null || kidLeft.getColumn() < left.getColumn()))
<           left = kidLeft;
<       }
< 
<   }
< 
<   @Override
<   public void reject() {
<     // FIXME: this might not work if the current node is an AMB
<     nodeType = REJECT;
<   }
< 
<   public void makeAmbiguity(AbstractParseNode pn) {
<     // if (isAmbNode()) {
<     // if (isInAmbiguityCluster(pn)) return;
<     // AbstractParseNode[] newKids = new AbstractParseNode[kids.length + 1];
<     // System.arraycopy(kids, 0, newKids, 0, kids.length);
<     // newKids[newKids.length - 1] = pn;
<     // kids = newKids;
<     //
<     // if(pn instanceof ParseNode)
<     // ((ParseNode) pn).replaceCycle(this, null);
<     // } else {
<     if (this == pn || (isAmbNode() && isInAmbiguityCluster(pn)))
<       return;
< 
<     assert getLine() == pn.getLine();
<     assert getColumn() == pn.getColumn();
< 
<     ParseNode left = new ParseNode(this.label, this.kids, this.nodeType, getLine(), getColumn(), isLayout, isIgnoreLayout);
< 
<     if (pn instanceof ParseNode)
<       ((ParseNode) pn).replaceCycle(this, left);
< 
<     setFields(AMB_LABEL, new AbstractParseNode[] { left, pn }, AbstractParseNode.AMBIGUITY);
< 
< 
<     assert (this.cachedHashCode == NO_HASH_CODE) : "Hashcode should not be cached during parsing because descendant nodes may change";
<     assert (!this.isParseProductionChain) : "PPC is not set to true during parsing because descendents may change";
<   }
< 
<   /**
<    * Transforms this ambuguity node into a non-ambiguous node by selecting either the left or right child.
<    * 
<    * @param n the left or right child.
<    */
<   public void disambiguate(AbstractParseNode n) {
<     assert isAmbNode();
<     assert n.isParseNode();
<     assert getChildren().length == 2 && (n == getChildren()[0] || n == getChildren()[1]);
---
> 	
> 	public Object toTreeBottomupAmb(BottomupTreeBuilder builder) {
>     	ArrayList<Object> collect = new ArrayList<Object>();
>     	addToTreeAmb(builder, collect);
>     	return builder.buildAmb(collect);
>     }
>         
>     private void addToTreeAmb(BottomupTreeBuilder builder, List<Object> collect) {
>     	for (int i = kids.length - 1; i >= 0; i--) {
>     		AbstractParseNode alt = kids[i];
>     		if (alt.isAmbNode()) {
>     			((ParseNode) alt).addToTreeAmb(builder, collect);
>     		} else {
>     			collect.add(alt.toTreeBottomup(builder));
>     		}
>     	}
>     }
> 
>     /**
>      * todo: stolen from TAFReader; move elsewhere
>      */
>     public static IStrategoList makeList(TermFactory factory, List<IStrategoTerm> terms) {
>         IStrategoList result = factory.makeList();
>         for (int i = terms.size() - 1; i >= 0; i--) {
>         	result = factory.makeListCons(terms.get(i), result);
>         }
>         return result;
>     }
> 
>     @Override
>     public String toString() {
>     	switch (nodeType) {
> 		case AbstractParseNode.AMBIGUITY:
>     		return "amb(" + Arrays.toString(kids) + ")";
> 		case AbstractParseNode.PARSENODE:
> 	        return "regular(aprod(" + label + ")," + Arrays.toString(kids) + ")";
> 		case AbstractParseNode.AVOID:
> 			return "avoid(" + getLabel() + "," + kids + ")";
> 		case AbstractParseNode.PREFER:
> 			return "prefer(" + getLabel() + "," + kids + ")";
> 		case AbstractParseNode.REJECT:
> 		    return "reject(" + getLabel() + "," + kids + ")";
> 		default:
> 			throw new NotImplementedException();
> 		}
>     }
> 
> 	@Override
> 	public int getNodeType() {
> 		return nodeType;
> 	}
> 
>     @Override
>     public AbstractParseNode[] getChildren() {
> 		return kids;
> 	}
140,220c295,309
<     setFields(n.isAmbNode() ? AMB_LABEL : n.getLabel(), n.getChildren(), n.getNodeType()) ;
<     cachedHashCode = NO_HASH_CODE;
<   }
<   
<   private boolean isInAmbiguityCluster(AbstractParseNode pn) {
<     for (AbstractParseNode existing : kids) {
<       if (pn == existing) {
<         return true;
<       } else if (existing.isAmbNode()) {
<         if (((ParseNode) existing).isInAmbiguityCluster(pn))
<           return true;
<       }
<     }
<     return false;
<   }
< 
<   private void replaceCycle(ParseNode before, ParseNode after) {
<     assert after != null;
< 
<     // only reductions for current char (right chain) are inspected
<     // XXX: is that assumption correct? what about epsylon productions that
<     // consume no chars?
<     if (isAmbNode()) { // all kids relate to current char
<       for (int i = 0; i < kids.length; i++)
<         replaceDescendantAt(before, after, i);
<     } else if (kids.length > 0) {
<       replaceDescendantAt(before, after, kids.length - 1);
<     }
<   }
< 
<   private void replaceDescendantAt(ParseNode before, ParseNode after, int index) {
<     AbstractParseNode kid = kids[index];
<     if (kid == before) {
<       kids[index] = after;
<       return; // no further inspection needed since cycles should not occur
<     } else if (kid instanceof ParseNode && kid.getLine() == getLine() && kid.getColumn() == getColumn()) {
<       ((ParseNode) kid).replaceCycle(before, after);
<     }
<   }
< 
<   @Override
<   public boolean isParseProductionChain() {
<     // REMARK: works because PPC property is not set during parsing, so
<     // descendants will not change
<     // assert isParseProductionChain == calculateIsParseProdChain(kids);
<     if (!isSetPPC)
<       initParseProductionChain();
<     return isParseProductionChain;
< //    return false;
<   }
< 
<   /**
<    * Initialize the {@link #isParseProductionChain} method for this node and any
<    * candidate chain nodes below it, without using recursion (which would
<    * potentially lead to a stack overflow).
<    */
<   private void initParseProductionChain() {
<     AbstractParseNode deepest = getDeepestNonChainNode();
<     if (deepest == this) { // fast path
<       isSetPPC = true;
<       isParseProductionChain = false;
<     } else {
<       setParseProductionChainUpTo(deepest == null, deepest);
<     }
<   }
< 
<   /**
<    * Find the deepest parse node that is clearly not a parse production chain
<    * node.
<    * 
<    * @see #isParseProductionChain
<    */
<   private AbstractParseNode getDeepestNonChainNode() {
<     AbstractParseNode current = this;
<     for (;;) {
<       AbstractParseNode[] kids = current.getChildren();
<       switch (kids.length) {
<       case 2:
<         if (current instanceof ParseNode) {
<           if (((ParseNode) current).isSetPPC)
<             return current.isParseProductionChain() ? null : current;
---
>     @Override
>     public boolean equals(Object obj) {
>         if(!(obj instanceof ParseNode))
>             return false;
>         if (obj == this)
>             return true;
>         final ParseNode o = (ParseNode)obj;
>         if (getNodeType() != o.getNodeType() || 
>         	label != o.label || 
>         	kids.length != o.kids.length || 
>         	hashCode() != o.hashCode())
>             return false;
>         for(int i = 0; i < kids.length; i++) {
>             if(!kids[i].equals(o.kids[i]))
>                 return false;
222,421c311,341
<         if (!kids[0].isParseProductionNode())
<           return kids[0];
<         current = kids[1];
<         break;
<       case 1:
<         current = kids[0];
<         break;
<       case 0:
<         return current.isParseProductionNode() ? null : current;
<       default:
<         return current;
<       }
<     }
<   }
< 
<   private void setParseProductionChainUpTo(boolean value, AbstractParseNode end) {
<     AbstractParseNode current = this;
<     AbstractParseNode next = this;
<     do {
<       current = next;
<       ParseNode parseCurrent = null;
<       if (current instanceof ParseNode)
<         parseCurrent = (ParseNode) current;
<       if (parseCurrent == null) {
<         assert current.isCycle() || current.isParseProductionNode();
<         return;
<       }
<       parseCurrent.isParseProductionChain = value;
<       parseCurrent.isSetPPC = true;
<       AbstractParseNode[] kids = parseCurrent.kids;
<       switch (kids.length) {
<       case 2:
<         next = kids[1];
<         break;
<       case 1:
<         next = kids[0];
<         break;
<       default:
<         return;
<       }
<     } while (current != end);
<   }
< 
<   // TODO: refactor
<   @Override
<   public Object toTreeBottomup(BottomupTreeBuilder builder) {
<     if (isAmbNode()) {
<       return toTreeBottomupAmb(builder);
<     }
<     builder.visitLabel(label);
<     ArrayList<Object> subtrees = new ArrayList<Object>(kids.length);
<     for (int i = 0; i < kids.length; i++) {
<       subtrees.add(kids[i].toTreeBottomup(builder));
<     }
< 
<     Object result = builder.buildNode(label, subtrees);
<     builder.endVisitLabel(label);
<     return result;
<   }
< 
<   public Object toTreeBottomupAmb(BottomupTreeBuilder builder) {
<     ArrayList<Object> collect = new ArrayList<Object>();
<     addToTreeAmb(builder, collect);
<     return builder.buildAmb(collect);
<   }
<   
<   @Override 
<   public Object toTreeTopdown(TopdownTreeBuilder builder) {
<     if(isAmbNode())
<         return builder.buildTreeAmb(this);
<     return builder.buildTreeNode(this);
<   }
< 
< 
<   private void addToTreeAmb(BottomupTreeBuilder builder, List<Object> collect) {
<     for (int i = kids.length - 1; i >= 0; i--) {
<       AbstractParseNode alt = kids[i];
<       if (alt.isAmbNode()) {
<         ((ParseNode) alt).addToTreeAmb(builder, collect);
<       } else {
<         collect.add(alt.toTreeBottomup(builder));
<       }
<     }
<   }
< 
<   /**
<    * todo: stolen from TAFReader; move elsewhere
<    */
<   public static IStrategoList makeList(TermFactory factory,
<       List<IStrategoTerm> terms) {
<     IStrategoList result = factory.makeList();
<     for (int i = terms.size() - 1; i >= 0; i--) {
<       result = factory.makeListCons(terms.get(i), result);
<     }
<     return result;
<   }
< 
<   @Override
<   public String toString() {
<     switch (nodeType) {
<     case AbstractParseNode.AMBIGUITY:
<       return "amb(" + Arrays.toString(kids) + ")";
<     case AbstractParseNode.PARSENODE:
<       return "regular(aprod(" + label + ")," + Arrays.toString(kids) + ")";
<     case AbstractParseNode.AVOID:
<       return "avoid(" + getLabel() + "," + Arrays.toString(kids) + ")";
<     case AbstractParseNode.PREFER:
<       return "prefer(" + getLabel() + "," + Arrays.toString(kids) + ")";
<     case AbstractParseNode.REJECT:
<       return "reject(" + getLabel() + "," + Arrays.toString(kids) + ")";
<     default:
<       throw new NotImplementedException();
<     }
<   }
< 
<   @Override
<   public int getNodeType() {
<     return nodeType;
<   }
< 
<   @Override
<   public AbstractParseNode[] getChildren() {
<     return kids;
<   }
< 
<   @Override
<   public boolean equals(Object obj) {
<     if (!(obj instanceof ParseNode) || !super.equals(obj))
<       return false;
<     if (obj == this)
<       return true;
<     final ParseNode o = (ParseNode) obj;
<     if (getNodeType() != o.getNodeType() || label != o.label
<         || kids.length != o.kids.length || hashCode() != o.hashCode())
<       return false;
<     for (int i = 0; i < kids.length; i++) {
<       if (!kids[i].equals(o.kids[i]))
<         return false;
<     }
<     return true;
<   }
< 
<   @Override
<   public int hashCode() {
<     if (cachedHashCode != NO_HASH_CODE)
<       return cachedHashCode;
<     final int prime = 31;
<     int result = prime * label;
<     for (AbstractParseNode n : kids)
<       result += (prime * n.hashCode());
<     cachedHashCode = result; // Assumption is that hashcode is not set during
<                              // parsing
<     return result;
<   }
< 
<   @Override
<   public String toStringShallow() {
<     if (isAmbNode())
<       return "Amb";
<     return "regular*(" + label + ", {" + kids.length + "})";
<   }
< 
<   private Boolean isEmpty;
< 
<   @Override
<   public boolean isEmpty() {
<     if (isEmpty != null)
<       return isEmpty;
< 
<     isEmpty = true;
< 
<     for (AbstractParseNode kid : kids)
<       if (!kid.isEmpty()) {
<         isEmpty = false;
<         break;
<       }
< 
<     return isEmpty;
<   }
< 
<   @Override
<   public AbstractParseNode getLeft() {
<     return left;
<   }
<   
<   @Override
<   public boolean isLayout() {
<     return isLayout;
<   }
< 
<   @Override
<   public boolean isIgnoreLayout() {
<     return isIgnoreLayout;
<   }
<   
<   /*
<    * private void log(){ System.out.println(this.toStringShallow()); for (int i
<    * = 0; i < kids.length; i++) { if(kids[i].isParseNode() ||
<    * kids[i].isAmbNode()) ((ParseNode)kids[i]).log(); } }
<    */
---
>         return true;
>     }
> 
>     @Override
>     public int hashCode() {
>         if (cachedHashCode != NO_HASH_CODE)
>             return cachedHashCode;
>         final int prime = 31;
>         int result = prime * label;
>         for(AbstractParseNode n : kids)
>             result += (prime * n.hashCode());
>         cachedHashCode = result; //Assumption is that hashcode is not set during parsing
>         return result;
>     }
> 
>     @Override
>     public String toStringShallow() {
>     	if (isAmbNode())
>     		return "Amb";
>         return "regular*(" + label + ", {" +  kids.length + "})";
>     }
> 	
>     /*
> 	private void log(){
> 		System.out.println(this.toStringShallow());
> 		for (int i = 0; i < kids.length; i++) {
> 			if(kids[i].isParseNode() || kids[i].isAmbNode())
> 				((ParseNode)kids[i]).log();			
> 		}
> 	}*/
> 
diff -r --exclude=.svn /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/ParseProductionNode.java src/org/spoofax/jsglr/client/ParseProductionNode.java
13d12
< 
21,22c20
<     public ParseProductionNode(int prod, int line, int column) {
<       super(line, column);
---
>     public ParseProductionNode(int prod) {
37c35
<     public Object toTreeBottomup(BottomupTreeBuilder builder) {
---
> 	public Object toTreeBottomup(BottomupTreeBuilder builder) {
43c41
<       return builder.buildTreeProduction(this);
---
>     	return builder.buildTreeProduction(this);
46d43
<     
49c46
<         return "\"" + prod + (prod >= 32 ? (":" + (char) prod) : "").replace("\"", "\\\"") + "\"";
---
>         return "" + prod;
52,53c49
<     @Override
<     public int getLabel() { return prod; }
---
>     public int getProduction() { return prod; }
57c53
<         if(!(obj instanceof ParseProductionNode) ||!super.equals(obj))
---
>         if(!(obj instanceof ParseProductionNode))
64c60
<         return 6359 * prod + super.hashCode();
---
>         return 6359 * prod;
81,100c77,81
< 
<   @Override
<   public boolean isEmpty() {
<     return false;
<   }
<   
<   @Override
<   public AbstractParseNode getLeft() {
<     return this;
<   }
<   
<   @Override
<   public boolean isLayout() {
<     return false;
<   }
< 
<   @Override
<   public boolean isIgnoreLayout() {
<     return false;
<   }
---
> 	
>     @Override
> 	public int getLabel() {
>     	return prod;
>     }
diff -r --exclude=.svn /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/ParseTable.java src/org/spoofax/jsglr/client/ParseTable.java
18,19d17
< import java.io.IOException;
< import java.io.InputStream;
24d21
< import java.util.LinkedList;
35,39d31
< import org.spoofax.jsglr.client.imploder.TreeBuilder;
< import org.spoofax.jsglr.io.ParseTableManager;
< import org.spoofax.jsglr.io.SGLR;
< import org.spoofax.jsglr.shared.SGLRException;
< import org.spoofax.terms.ParseError;
59,60d50
<     
<     private static SGLR layoutParser;
87c77
<     
---
> 
102c92,94
<     private transient KeywordRecognizer keywords;
---
> 	private transient KeywordRecognizer keywords;
> 
>     private static final ParseProductionNode[] productionNodes = new ParseProductionNode[256 + 1];
103a96,101
>     static {
>     	for(int i = 0; i < productionNodes.length; i++) {
>     		productionNodes[i] = new ParseProductionNode(i);
>     	}
>     }
>                                              
141c139
<         
---
> 
271d268
<     
275c272
<       if (attr.getName().equals("attrs")) {
---
>         if (attr.getName().equals("attrs")) {
278,281c275
<             boolean isIgnoreLayout = false;
<             IStrategoTerm layoutConstraint = null;
<             boolean isNewlineEnforced = false;
<             boolean isLongestMatch = false;
---
>             boolean isCompletion = false;
321a316,317
>                        		} else if (child.getSubtermCount() == 0 && child.getName().equals("completion")) {
>                     		    isCompletion = true;
323,349d318
<                         else if (child.getSubtermCount() == 0 && (child.getName().equals("ignore-layout") || child.getName().equals("ignore-indent"))) {
<                           isIgnoreLayout = true;
<                         }
<                         else if (child.getSubtermCount() == 1 && child.getName().equals("layout")) {
<                           layoutConstraint = child.getSubterm(0);
<                           if (Term.isTermString(layoutConstraint))
<                             try {
<                               if (layoutParser == null) {
<                                 try {
<                                   InputStream in = getClass().getResourceAsStream("indentation/LayoutConstraint.tbl");
<                                   ParseTable pt = new ParseTableManager(factory).loadFromStream(in);
<                                   layoutParser =  new SGLR(new TreeBuilder(), pt);
<                                 } catch (ParseError e) {
<                                   e.printStackTrace();
<                                 } catch (IOException e) {
<                                   e.printStackTrace();
<                                 }
<                               }
<                               layoutConstraint = (IStrategoTerm) layoutParser.parse(Term.asJavaString(layoutConstraint), "", "Constraint");
<                             } catch (SGLRException e) {
<                               throw new InvalidParseTableException("invalid layout constraint " + Term.asJavaString(layoutConstraint) + ": " + e.getMessage());
<                             } catch (InterruptedException e) {
<                               e.printStackTrace();
<                             }
<                         }
<                         else if (child.getSubtermCount() == 0 && child.getName().equals("enforce-newline")) {
<                           isNewlineEnforced = true;
351,354d319
<                         else if (child.getSubtermCount() == 0 && child.getName().equals("longest-match")) {
<                           isLongestMatch = true;
<                         }
<                     	}
364c329
<             return new ProductionAttributes(term, type, isRecover, isIgnoreLayout, layoutConstraint, isNewlineEnforced, isLongestMatch);
---
>             return new ProductionAttributes(term, type, isRecover, isCompletion);
366c331
<             return new ProductionAttributes(null, ProductionType.NO_TYPE, false, false, null, false, false);
---
>             return new ProductionAttributes(null, ProductionType.NO_TYPE, false, false);
428c393,394
<                 item = makeReduce(productionArity, label, status, isRecoverAction);
---
>                 boolean isCompletionAction = getLabel(label).getAttributes().isCompletionProduction();
>                 item = makeReduce(productionArity, label, status, isRecoverAction, isCompletionAction);
450,451c416,417
<         List<RangeList> ret = new LinkedList<RangeList>();
<         for (int i=0;i<list.getSubtermCount(); i++) {
---
>         RangeList[] ret = new RangeList[list.getSubtermCount()];
>         for (int i=0;i<ret.length; i++) {
467,472c433,450
<             ret.add(parseRanges(l));
<             
<             if (n.getSubtermCount() > 0) 
<               throw new InvalidParseTableException("Multiple lookahead not fully supported"); 
<             for (IStrategoTerm nt : n.getAllSubterms())
<               ret.add(parseRanges((IStrategoList) nt.getSubterm(0)));
---
>             if (n.getSubtermCount() > 0 && l.getSubtermCount() == 1) {
>                 // This handles restrictions like:
>                 //   LAYOUT? -/- [\/].[\/]
>                 // where there is no other restriction that starts with a [\/]
>                 
>                 ret[i] = parseRanges(l);
>             } else if (n.getSubtermCount() > 0) {
>                 // This handles restrictions like:
>                 //   LAYOUT? -/- [\/].[\/\+].[\*]
>                 throw new InvalidParseTableException("Multiple lookahead not fully supported");
>             } else {
>                 // This handles restrictions like:
>                 //   LAYOUT? -/- [\/].[\/]
>                 //   LAYOUT? -/- [\/].[\*]
>                 //   LAYOUT? -/- [\/].[\{]
> 
>                 ret[i] = parseRanges(l);
>             }
474c452
<         return ret.toArray(new RangeList[ret.size()]);
---
>         return ret;
481,482c459,460
<     private Reduce makeReduce(int arity, int label, int status, boolean isRecoverAction) {
<         Reduce r = new Reduce(arity, label, status, isRecoverAction);
---
>     private Reduce makeReduce(int arity, int label, int status, boolean isRecoverAction, boolean isCompletionAction) {
>         Reduce r = new Reduce(arity, label, status, isRecoverAction, isCompletionAction);
570c548
<     
---
> 
642a621,624
>     public AbstractParseNode lookupProduction(int currentToken) {
>     	return productionNodes[currentToken];
>     }
> 
diff -r --exclude=.svn /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/ParserHistory.java src/org/spoofax/jsglr/client/ParserHistory.java
49c49
<     public void readRecoverToken(SGLR myParser, boolean keepRecoveredLines) {  
---
>     public void readRecoverToken(SGLR myParser, boolean keepStacks) { 
56,57c56,59
<                     if(indentHandler.lineMarginEnded() || myParser.getCurrentToken()==SGLR.EOF)
<                         keepNewLinePoint(myParser, myParser.tokensSeen-1, true, indentHandler);
---
>                     if (myParser.getCurrentToken()==SGLR.EOF)
>                         keepNewLinePoint(myParser, myParser.getParserLocation(), !keepStacks, indentHandler);
>                     else if (indentHandler.lineMarginEnded())
>                         keepNewLinePoint(myParser, myParser.getParserLocation()-1, !keepStacks, indentHandler);
66,70c68,69
<             if(keepRecoveredLines){
<                 recoveryIndentHandler.updateIndentation(myParser.getCurrentToken());
<                 if(recoveryIndentHandler.lineMarginEnded() || myParser.getCurrentToken()==SGLR.EOF)
<                     keepNewLinePoint(myParser, tokenIndex, false, recoveryIndentHandler);
<             }    
---
>             if(keepStacks)
>             	addStackNodesToNewLinePoint(myParser);
72,73c71
<         tokenIndex++;
<         
---
>         tokenIndex++;        
97,98c95,99
<         if(indentHandler.lineMarginEnded() || myParser.getCurrentToken()==SGLR.EOF || tokenIndex == 1)
<             keepNewLinePoint(myParser, myParser.tokensSeen-1, false, indentHandler);
---
>         //assert myParser.tokensSeen == this.getTokenIndex(): "inconsistentcy in token index";
>         if (indentHandler.lineMarginEnded() || myParser.getCurrentToken()==SGLR.EOF || tokenIndex == 1)
>             keepNewLinePoint(myParser, myParser.getParserLocation() - 1, false, indentHandler);
>         else if (indentHandler.lineMarginEnded() || myParser.getCurrentToken()==SGLR.EOF || tokenIndex == 1)
>             keepNewLinePoint(myParser, myParser.getParserLocation() - 1, false, indentHandler);
112c113
<         if(!inRecoverMode){
---
>         if (!inRecoverMode){
115a117,131
>     
>     private void addStackNodesToNewLinePoint(SGLR myParser) {
> 		// TODO Auto-generated method stub
>     	int tokensSeen = myParser.getParserLocation() - 1;
>     	for (int i = newLinePoints.size()-1; i >= 0; i--) {
> 			IndentInfo newLinePoint = newLinePoints.get(i);
> 			if(newLinePoint.getTokensSeen() == tokensSeen){
> 	            newLinePoint.fillStackNodes(myParser.activeStacks);
> 	            return;
> 	        }
> 			if(newLinePoint.getTokensSeen() < tokensSeen)
> 				return;
> 		}
> 	}
> 
118c134
<         String fragment="";
---
>         StringBuilder fragment = new StringBuilder();
120c136,137
<             if(i >= recoverTokenCount)
---
>         	int nextChar = readCharAt(i, chars);
>             if(i >= recoverTokenCount || nextChar == -1)
122c139
<             fragment+= (char)readCharAt(i, chars);
---
>             fragment.append((char)nextChar);
124c141
<         return fragment;
---
>         return fragment.toString();
128c145
<         String fragment="";
---
>         StringBuilder fragment = new StringBuilder();
133c150
<             fragment+= (char)currentTok;
---
>             fragment.append((char)currentTok);
136c153
<         return fragment;
---
>         return fragment.toString();
diff -r --exclude=.svn /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/Path.java src/org/spoofax/jsglr/client/Path.java
10d9
< 
20c19
< 	public int getRecoverCount()
---
> 	public int getRecoverWeight()
24c23
< 			result += link.recoverCount;           
---
> 			result += link.recoverWeight;           
27c26
< 			result += parent.getRecoverCount();
---
> 			result += parent.getRecoverWeight();
32c31
< 	public int getRecoverCount(int maxCharLength)
---
> 	public int getRecoverCount()
34,36c33,40
< 		if(parent == null || this.length <= maxCharLength)
< 			return getRecoverCount();
< 		return parent.getRecoverCount(maxCharLength);
---
> 		int result = 0;
> 		if(link != null) {
> 			result += link.recoverCount;           
> 		}
> 		if(parent != null) {
> 			result += parent.getRecoverCount();
> 		}
> 		return result;        
38c42
< 
---
> 	
58,61d61
< 	
< 	public int getParentCount() {
< 	  return parentCount;
< 	}
diff -r --exclude=.svn /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/PathListPool.java src/org/spoofax/jsglr/client/PathListPool.java
5d4
< 
15c14
< 	public int asyncCacheMisses = 0;
---
> 	public static int asyncCacheMisses = 0;
18c17
< //	private static PathListPool asyncInstance = new PathListPool();
---
> 	private static PathListPool asyncInstance = new PathListPool();
29c28
< 		return new PathListPool();
---
> 		return asyncInstance;
52c51
< 	public void resetPerformanceCounters() {
---
> 	public static void resetPerformanceCounters() {
diff -r --exclude=.svn /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/PooledPathList.java src/org/spoofax/jsglr/client/PooledPathList.java
4d3
< 
diff -r --exclude=.svn /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/Production.java src/org/spoofax/jsglr/client/Production.java
19c19
<   static final long serialVersionUID = 8767621343854666185L;
---
>     static final long serialVersionUID = 8767621343854666185L;
21c21
<   public final int arity;
---
>     public final int arity;
23c23
<   public final int label;
---
>     public final int label;
25c25,27
<   public final int status;
---
>     public final int status;
>     
>     private final boolean isRecover;
27,74c29,88
<   private final boolean isRecover;
< 
<   public Production(int arity, int label, int status, boolean isRecover) {
<     this.arity = arity;
<     this.label = label;
<     this.status = status;
<     this.isRecover = isRecover;
<   }
< 
<   public AbstractParseNode apply(AbstractParseNode[] kids, int line, int column, boolean isLayout, boolean isIgnoreLayout) {
<     switch (status) {
<     case REJECT:
<       return new ParseNode(label, kids, AbstractParseNode.REJECT, line, column, isLayout, isIgnoreLayout);
<     case AVOID:
<       return new ParseNode(label, kids, AbstractParseNode.AVOID, line, column, isLayout, isIgnoreLayout);
<     case PREFER:
<       return new ParseNode(label, kids, AbstractParseNode.PREFER, line, column, isLayout, isIgnoreLayout);
<     case NO_TYPE:
<       return new ParseNode(label, kids, AbstractParseNode.PARSENODE, line, column, isLayout, isIgnoreLayout);
<     }
<     throw new IllegalStateException();
<   }
< 
<   public boolean isRejectProduction() {
<     return status == REJECT;
<   }
< 
<   public boolean isRecoverProduction() {
<     return isRecover;
<   }
< 
<   @Override
<   public boolean equals(Object obj) {
<     if (!(obj instanceof Production))
<       return false;
<     Production o = (Production) obj;
<     return arity == o.arity && label == o.label && status == o.status;
<   }
< 
<   @Override
<   public int hashCode() {
<     final int prime = 31;
<     int result = 1;
<     result = prime * result + arity;
<     result = prime * result + label;
<     result = prime * result + status;
<     return result;
<   }
---
>     private final boolean isCompletion;
> 
>     public Production(int arity, int label, int status, boolean isRecover, boolean isCompletion) {
>         this.arity = arity;
>         this.label = label;
>         this.status = status;
>         this.isRecover = isRecover;
>         this.isCompletion = isCompletion;
>     }
> 
>     public AbstractParseNode apply(AbstractParseNode[] kids) {
>         switch(status) {
>         case REJECT:
>             return new ParseNode(label, kids, AbstractParseNode.REJECT);
>         case AVOID:
>             return new ParseNode(label, kids, AbstractParseNode.AVOID);
>         case PREFER:
>             return new ParseNode(label, kids, AbstractParseNode.PREFER);
>         case NO_TYPE:
>             return new ParseNode(label, kids, AbstractParseNode.PARSENODE);
>         }
>         throw new IllegalStateException();
>     }
> 
>     public boolean isRejectProduction() {
>         return status == REJECT;
>     }
>     
>     public boolean isRecoverProduction() {
>         return isRecover;
>     }
> 
>     public boolean isCompletionProduction() {
>         return isCompletion;
>     }
> 
>     /**
>      * -> "@#$"{completion} (added for performance reasons)
>      */
>     public boolean isCompletionStartProduction() {
>         return isCompletion && this.arity == 0; 
>     }
> 
>     @Override
>     public boolean equals(Object obj) {
>         if(!(obj instanceof Production))
>             return false;
>         Production o = (Production)obj;
>         return arity == o.arity && label == o.label && status == o.status;
>     }
> 
>     @Override
> 	public int hashCode() {
> 		final int prime = 31;
> 		int result = 1;
> 		result = prime * result + arity;
> 		result = prime * result + label;
> 		result = prime * result + status;
> 		return result;
> 	}
diff -r --exclude=.svn /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/ProductionAttributes.java src/org/spoofax/jsglr/client/ProductionAttributes.java
24,27c24,25
<     private final boolean isIgnoreLayout;
<     private final IStrategoTerm layoutConstraint;
<     private final boolean isNewlineEnforced;
<     private final boolean isLongestMatch;
---
> 
>     private final boolean isCompletion;
31c29
<     ProductionAttributes(IStrategoTerm ctor, int type, boolean isRecover, boolean isIgnoreIndent, IStrategoTerm layoutConstraint, boolean isNewlineEnforced, boolean isLongestMatch) {
---
>     ProductionAttributes(IStrategoTerm ctor, int type, boolean isRecover, boolean isCompletion) {
35,38c33
<         this.isIgnoreLayout = isIgnoreIndent;
<         this.layoutConstraint = layoutConstraint;
<         this.isNewlineEnforced = isNewlineEnforced;
<         this.isLongestMatch = isLongestMatch;
---
>         this.isCompletion = isCompletion;
52,62c47,49
<     
<     public boolean isIgnoreLayout() {
<       return isIgnoreLayout;
<     }
<     
<     public IStrategoTerm getLayoutConstraint() {
<       return layoutConstraint;
<     }
<     
<     public boolean isNewlineEnforced() {
<       return isNewlineEnforced;
---
> 
>     public boolean isCompletionProduction() {
>         return isCompletion;
68,71d54
< 
<     public boolean isLongestMatch() {
<       return isLongestMatch;
<     }
Only in /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client: RecoverDisambiguator.java
diff -r --exclude=.svn /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/RecoverNode.java src/org/spoofax/jsglr/client/RecoverNode.java
4d3
< 
diff -r --exclude=.svn /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/RecoveryConnector.java src/org/spoofax/jsglr/client/RecoveryConnector.java
3,7d2
< import org.spoofax.jsglr.shared.ArrayDeque;
< import org.spoofax.jsglr.shared.BadTokenException;
< import org.spoofax.jsglr.shared.SGLRException;
< import org.spoofax.jsglr.shared.TokenExpectedException;
< 
9,232c4,178
<     private SGLR mySGLR;
<     private IRecoveryParser recoveryParser;
<     private RegionRecovery skipRecovery;
<     private boolean useBridgeParser;
<     private boolean useFineGrained;
<     private boolean onlyFineGrained;
<     
<     
<     public void setOnlyFineGrained(boolean onlyFG) {
<         onlyFineGrained=onlyFG;        
<     }
<     
<     public void setUseFineGrained(boolean useFG) {
<         useFineGrained=useFG;        
<     }
<     
<     public void setUseBridgeParser(boolean useBridgeParser) {
<         this.useBridgeParser = useBridgeParser;
<     }
< 
<     public RecoveryConnector(SGLR parser, IRecoveryParser recoveryParser){
<         mySGLR=parser;        
<         skipRecovery = new RegionRecovery(mySGLR); 
<         useFineGrained=true;
<         onlyFineGrained=false;
<         if(recoveryParser!=null){
<             this.recoveryParser = recoveryParser;
<             useBridgeParser=true;
<         }
<         else
<             useBridgeParser=false;
<         
<     }    
< 
<     private ParserHistory getHistory() {
<         return mySGLR.getHistory();
<     }
<     public void recover() throws InterruptedException {
<         mySGLR.getPerformanceMeasuring().startRecovery();
<         combinedRecover();
<         mySGLR.getPerformanceMeasuring().endRecovery(recoverySucceeded());
<     }
< 
<     private void combinedRecover() throws InterruptedException {
<         if(onlyFineGrained){
<             mySGLR.getPerformanceMeasuring().startFG();
<             boolean fg=tryFineGrainedRepair();
<             if(fg){
<             	System.out.println("FG-only Succeeded");
<             }
<             mySGLR.getPerformanceMeasuring().endFG(fg);
<             return;
<         }
<         mySGLR.getPerformanceMeasuring().startCG();
<         boolean skipSucceeded = skipRecovery.selectErroneousFragment(); //decides whether whitespace parse makes sense
<         /*
<         System.out.println();
<         System.out.println("------------------------------");
<         System.out.println("SKIP-RESULT: "+skipSucceeded);
<         System.out.print(skipRecovery.getErrorFragment());
<         System.out.println();
<         System.out.println("------------------------------");
<         */
<         mySGLR.getPerformanceMeasuring().endCG(skipSucceeded);
<         mySGLR.acceptingStack=null;
<         mySGLR.activeStacks.clear();
<         //BRIDGE REPAIR
<         if(useBridgeParser){            
<             String errorFragment = skipRecovery.getErrorFragmentWithLeftMargin();
<             mySGLR.getPerformanceMeasuring().startBP();
<             boolean succeeded = tryBridgeRepair(errorFragment);
<             mySGLR.getPerformanceMeasuring().endBP(succeeded);
<             if(succeeded){
<             	//System.out.println("BP-Succeeded");
<                 return;
<             }
<         }
<         //FINEGRAINED REPAIR 
<         if(useFineGrained){
<             mySGLR.getPerformanceMeasuring().startFG();
<             boolean FGSucceeded=tryFineGrainedRepair();
<             mySGLR.getPerformanceMeasuring().endFG(FGSucceeded);
<             if(FGSucceeded){ //FG succeeded  
<                 addSkipOption(skipSucceeded);
<                 //System.out.println("FG-Succeeded");
<                 return;
<             }
<         }
<         //WHITESPACE REPAIR
<         if (skipSucceeded) { 
<             getHistory().deleteLinesFrom(skipRecovery.getStartIndexErrorFragment());//TODO: integrate with FG and BP
<             getHistory().resetRecoveryIndentHandler(skipRecovery.getStartLineErrorFragment().getIndentValue());
<             parseErrorFragmentAsWhiteSpace(false);
<             boolean rsSucceeded=parseRemainingTokens(true);
<             /*
<             if(rsSucceeded)
<             	System.out.println("RS-Succeeded");
<             else
<             	System.err.println("RS failed");
<             */
<             
<         }
<     }
< 
<     private void addSkipOption(boolean skipSucceeded) throws InterruptedException {
<         ArrayDeque<Frame> fgStacks=new ArrayDeque<Frame>();
<         fgStacks.addAll(mySGLR.activeStacks);
<         if(skipSucceeded && parseErrorFragmentAsWhiteSpace(false) && parseRemainingTokens(false)){
<             for (Frame frame : mySGLR.activeStacks) {
<                 for (Link l : frame.getAllLinks()) {
<                     l.recoverCount = 5;
<                 }
<             }                        
<             for (Frame frame : fgStacks) {
<                 mySGLR.addStack(frame);
<             } 
<         }
<     }
<     
<     private boolean recoverySucceeded() {
<         return (mySGLR.activeStacks.size()>0 || mySGLR.acceptingStack!=null);
<     }
< 
<     private boolean tryFineGrainedRepair() throws InterruptedException {
<         FineGrainedOnRegion fgRepair=new FineGrainedOnRegion(mySGLR); 
<         if(!onlyFineGrained){
<             fgRepair.setRegionInfo(skipRecovery.getErroneousRegion(), skipRecovery.getAcceptPosition());
<         }
<         else{
<             fgRepair.setInfoFGOnly();
<         }
<         fgRepair.recover();
<         fgRepair.parseRemainingTokens();
<         return recoverySucceeded();
<     }
< 
<     private boolean tryBridgeRepair(String errorFragment) throws InterruptedException {
<         String repairedFragment = repairBridges(errorFragment);
<         mySGLR.activeStacks.addAll(skipRecovery.getStartLineErrorFragment().getStackNodes());   
<         tryParsing(repairedFragment, false);      
<         return parseRemainingTokens(true);
<     }
< 
<     private String repairBridges(String errorFragment) {        
<         try {            
<             IRecoveryResult bpResult = null;
<             bpResult = recoveryParser.recover(errorFragment);
<             return bpResult.getResult();
<         } catch (TokenExpectedException e) {
<             e.printStackTrace();
<         } catch (BadTokenException e) {
<             e.printStackTrace();
<         } catch (SGLRException e) {
<             e.printStackTrace();
<         } catch (Exception e) {
<             e.printStackTrace();
<         }
<         return  errorFragment;
<     }
<     
<     private void tryParsing(String fragment, boolean asLayout) throws InterruptedException {
<         // Skip any leading whitespace, since we already parsed up to that point
<         int indexFragment = findFirstNonLayoutToken(fragment);
<         while(indexFragment<fragment.length() && mySGLR.activeStacks.size()>0) {                        
<             mySGLR.setCurrentToken(fragment.charAt(indexFragment));
<             indexFragment++;
<             if(!asLayout)
<                 mySGLR.doParseStep();
<             else
<                 parseAsLayout();
<         }       
<     }
<     
<     public boolean parseErrorFragmentAsWhiteSpace(boolean keepLines) throws InterruptedException {
<         //System.out.println("---------- Start WhiteSpace Parsing ----------");
<         mySGLR.activeStacks.clear();
<         mySGLR.activeStacks.addAll(skipRecovery.getStartLineErrorFragment().getStackNodes());
<         getHistory().setTokenIndex(skipRecovery.getStartPositionErrorFragment());
<         while((getHistory().getTokenIndex()<skipRecovery.getEndPositionErrorFragment()) && mySGLR.activeStacks.size()>0 && mySGLR.acceptingStack==null){        
<             getHistory().readRecoverToken(mySGLR, keepLines);
<             //System.out.print((char)mySGLR.currentToken);
<             parseAsLayout();           
<         }
<         //System.out.println("----------- End WhiteSpace Parsing ---------");
<         return recoverySucceeded();
<     }
<     
<     public boolean parseRemainingTokens(boolean keepHistory) throws InterruptedException {
<         //System.out.println("------------- REMAINING CHARACTERS --------------- ");
<         //System.out.println();
<         getHistory().setTokenIndex(skipRecovery.getEndPositionErrorFragment());
<         while(
<         		(!getHistory().hasFinishedRecoverTokens()) 
<         		&& mySGLR.activeStacks.size()>0 
<         		&& mySGLR.acceptingStack==null
<         )
<         {        
<             getHistory().readRecoverToken(mySGLR, keepHistory);
<             //System.out.print((char)mySGLR.currentToken);
<             //System.out.print("("+mySGLR.currentToken+")");
<             mySGLR.doParseStep();            
<         }  
<         return recoverySucceeded();
<     }
<     
<     private void parseAsLayout() throws InterruptedException {
<         if(!isLayoutCharacter((char)mySGLR.getCurrentToken()) && mySGLR.getCurrentToken()!=SGLR.EOF){
<             mySGLR.setCurrentToken(' ');
<         }
<         mySGLR.doParseStep();
<     }
<     
<     public static boolean isLayoutCharacter(char aChar) {
<         // TODO: Move this to the parse table class; only it truly can now layout characters
<         return aChar==' ' || aChar == '\t' || aChar=='\n';
<     }
< 
<     private int findFirstNonLayoutToken(String repairedFragment) {
<         int indexFragment=0;
<         while(indexFragment<repairedFragment.length()-1 && isLayoutCharacter(repairedFragment.charAt(indexFragment)))
<             indexFragment++;
<         return indexFragment;
<     }
< 
---
> 	private SGLR mySGLR;
> 	private IntegratedRecoverySettings settings;
> 	private RegionRecovery regionSelector;
> 	private FineGrainedRecovery fgRegionalRecovery; // used on errorneous region (or on region near failure line)
> 	private FineGrainedRecovery fgCursorLineRecovery; // intended for recovery near cursor
> 
> 	public void setFgRegionalRecovery(FineGrainedRecovery fgRegionalRecovery) {
> 		this.fgRegionalRecovery = fgRegionalRecovery;
> 	}
> 
> 	private ParserHistory getHistory() {
> 		return mySGLR.getHistory();
> 	}
> 
> 	public RecoveryConnector(SGLR parser){
> 		this(parser, IntegratedRecoverySettings.createDefaultSettings(), FineGrainedSetting.createDefaultSetting());
> 	}
> 	
> 	public RecoveryConnector(SGLR parser, IntegratedRecoverySettings settings) {
> 		this(parser, settings, FineGrainedSetting.createDefaultSetting());
> 	}
> 
> 	public int getMaxNumberOfRecoverApplicationsGlobal(){
> 		return this.settings.getMaxNumberOfRecoverApplicationsGlobal();
> 	}
> 	
> 	public RecoveryConnector(SGLR parser, IntegratedRecoverySettings settings, FineGrainedSetting fgSettings) {
> 		this.mySGLR = parser;
> 		this.regionSelector = new RegionRecovery(mySGLR);
> 		this.settings = settings;
> 		this.fgCursorLineRecovery = new FineGrainedRecovery(mySGLR, FineGrainedSetting.createCursorLineSetting());		
> 		this.fgRegionalRecovery = new FineGrainedRecovery(mySGLR, fgSettings);
> 	}
> 	
> 	public void recover() {
> 		mySGLR.getPerformanceMeasuring().startRecovery();
> 		boolean recoverySucceeded = combinedRecover();
> 		mySGLR.getPerformanceMeasuring().endRecovery(recoverySucceeded);
> 	}
> 
> 	private boolean combinedRecover() {
> 		int failureOffset = mySGLR.getParserLocation();
> 		int failureLineIndex = getHistory().getLineOfTokenPosition(failureOffset - 1);
> 		int cursorLineIndex = getHistory().getLineOfTokenPosition(mySGLR.getCursorLocation());
> 
> 		mySGLR.getPerformanceMeasuring().addFailureLocation(failureOffset);
> 
> 		if (settings.useFineGrained() && settings.useCursorLocation()) {
> 			if(tryFineGrainedOnCursorLine(failureOffset, failureLineIndex, cursorLineIndex)){
> 				//System.out.println("FG on cursor line succeeded!");
> 				return true;
> 			}
> 		}
> 		boolean skipSucceeded = false;
> 		if (settings.useRegionSelection() || settings.useRegionRecovery()) {
> 			skipSucceeded = trySelectErroneousRegion(failureOffset, failureLineIndex, cursorLineIndex);
> 		}
> 		if (settings.useFineGrained()) {
> 			boolean fgSucceeded = tryFineGrainedRecovery(failureOffset, failureLineIndex, skipSucceeded);
> 			if (parseRemainingTokens(true)) {
> 				return true;
> 			} else if (fgSucceeded && mySGLR.getParserLocation() > failureOffset) {
> 				return combinedRecover();
> 			}
> 		}
> 		if (settings.useRegionRecovery() && skipSucceeded) {
> 			parseErrorFragmentAsWhiteSpace();
> 			if (parseRemainingTokens(true))
> 				return true;
> 			else if (mySGLR.getParserLocation() > failureOffset)
> 				return combinedRecover();
> 		}
> 		return false;
> 	}
> 
> 	private boolean tryFineGrainedOnCursorLine(int failureOffset, int failureLineIndex, int cursorLineIndex) {
> 		if(isLikelyErrorLocation(failureLineIndex, cursorLineIndex)){
> 			/*			
> 			int startTok = getHistory().getLine(Math.max(0, cursorLineIndex - 1)).getTokensSeen();		
> 			int endTok = failureOffset;
> 			System.out.println(getHistory().getFragment(startTok, endTok, mySGLR.currentInputStream));
> 			*/
> 			
> 			mySGLR.getPerformanceMeasuring().startFGOnCursor();
> 			boolean fgSucceededOnCursor = fgCursorLineRecovery.recover(failureOffset, cursorLineIndex);
> 			mySGLR.getPerformanceMeasuring().endFGOnCursor(fgSucceededOnCursor);
> 			if (fgSucceededOnCursor && parseRemainingTokens(true)) {
> 				return true;
> 			}
> 		}
> 		//System.out.println("FG on cursor line failed!");
> 		return false;
> 	}
> 
> 	private boolean trySelectErroneousRegion(int failureOffset, int failureLineIndex, int cursorLineIndex) {
> 		boolean skipSucceeded;
> 		mySGLR.getPerformanceMeasuring().startCG();
> 		if(settings.useCursorLocation() && isPossibleErrorLocation(failureLineIndex, cursorLineIndex))
> 			skipSucceeded = regionSelector.selectErroneousFragment(failureOffset, failureLineIndex, cursorLineIndex); 
> 		else
> 			skipSucceeded = regionSelector.selectErroneousFragment(failureOffset, failureLineIndex);
> 		mySGLR.getPerformanceMeasuring().endCG(skipSucceeded);
> 		mySGLR.acceptingStack = null;
> 		mySGLR.activeStacks.clear();
> 		return skipSucceeded;
> 	}
> 
> 	private boolean tryFineGrainedRecovery(int failureOffset, int failureLineIndex, boolean skipSucceeded) {
> 		mySGLR.getPerformanceMeasuring().startFG();
> 		boolean fgSucceeded = false;
> 		if (skipSucceeded && settings.useRegionSelection()) {
> 			StructureSkipSuggestion erroneousRegion = regionSelector.getErroneousRegion();
> 			fgSucceeded = fgRegionalRecovery.recover(
> 				failureOffset, 
> 				Math.min(erroneousRegion.getIndexHistoryEnd(), failureLineIndex), 
> 				erroneousRegion.getStartSkip().getTokensSeen(), 
> 				erroneousRegion.getEndSkip().getTokensSeen()
> 			);
> 		} else {
> 			fgSucceeded = fgRegionalRecovery.recover(failureOffset, failureLineIndex);
> 		}
> 		mySGLR.getPerformanceMeasuring().endFG(fgSucceeded);
> 		return fgSucceeded;
> 	}
> 
> 	private boolean isLikelyErrorLocation(int failureLineIndex, int cursorLineIndex) {
> 		return 
> 			isPossibleErrorLocation(failureLineIndex, cursorLineIndex) && 
> 			failureLineIndex - cursorLineIndex <= 10;
> 	}
> 
> 	private boolean isPossibleErrorLocation(int failureLineIndex, int cursorLineIndex) {
> 		return mySGLR.isSetCursorLocation() && failureLineIndex >= cursorLineIndex;
> 	}
> 
> 	public boolean parseRemainingTokens(boolean keepHistory) {
> 		while ((!getHistory().hasFinishedRecoverTokens())
> 				&& mySGLR.activeStacks.size() > 0
> 				&& mySGLR.acceptingStack == null) {
> 			getHistory().readRecoverToken(mySGLR, keepHistory);
> 			mySGLR.doParseStep();
> 		}
> 		return recoverySucceeded();
> 	}
> 
> 	private boolean recoverySucceeded() {
> 		return (mySGLR.activeStacks.size() > 0 || mySGLR.acceptingStack != null);
> 	}
> 
> 	public boolean parseErrorFragmentAsWhiteSpace() {
> 		mySGLR.activeStacks.clear();
> 		mySGLR.activeStacks.addAll(regionSelector.getStartLineErrorFragment().getStackNodes());
> 		getHistory().setTokenIndex(regionSelector.getStartPositionErrorFragment());
> 		getHistory().resetRecoveryIndentHandler(regionSelector.getStartLineErrorFragment().getIndentValue());
> 		while ((getHistory().getTokenIndex() < regionSelector.getEndPositionErrorFragment())
> 				&& mySGLR.activeStacks.size() > 0
> 				&& mySGLR.acceptingStack == null) {
> 			getHistory().readRecoverToken(mySGLR, false);
> 			parseAsLayout();
> 		}
> 		return recoverySucceeded();
> 	}
> 
> 	private void parseAsLayout() {
> 		if (!isLayoutCharacter((char) mySGLR.getCurrentToken()) && mySGLR.getCurrentToken() != SGLR.EOF) {
> 			mySGLR.setCurrentToken(' ');
> 		}
> 		mySGLR.doParseStep();
> 	}
> 
> 	public static boolean isLayoutCharacter(char aChar) {
> 		// TODO: Move this to the parse table class; only it truly can know
> 		// layout characters
> 		return aChar == ' ' || aChar == '\t' || aChar == '\n';
> 	}
diff -r --exclude=.svn /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/RecoveryPerformance.java src/org/spoofax/jsglr/client/RecoveryPerformance.java
11a12,13
>     private ArrayList<Integer> FGOnCursorTimes;
>     private long startFGOnCursor;
19a22
>     private ArrayList<Boolean> FGOnCursorResults;
22a26,32
>     private int recoverCount; 
> 
>     private ArrayList<Integer> failureLocations;
>     
>     public ArrayList<Integer> getFailureLocations() {
> 		return failureLocations;
> 	}
26a37
>         FGOnCursorTimes=new ArrayList<Integer>();
31a43
>         FGOnCursorResults=new ArrayList<Boolean>();
33a46
>         failureLocations = new ArrayList<Integer>();
104c117,127
<     
---
> 
> 	public void startFGOnCursor() {
>         startFGOnCursor = System.currentTimeMillis();
> 	}
> 
> 	public void endFGOnCursor(boolean succeeded) {
>         long FGTime=System.currentTimeMillis()-startFGOnCursor;
>         FGOnCursorTimes.add((int)FGTime);
>         FGOnCursorResults.add(succeeded);
> 	}
> 
123a147,158
> 
>     public void addFailureLocation(int tokensSeen) {
> 		failureLocations.add(tokensSeen);		
> 	}
>     
> 	public void setRecoverCount(int recoverCount) {
> 		this.recoverCount = recoverCount;
> 	}
>     
> 	public int getRecoverCount() {
> 		return recoverCount;
> 	}
diff -r --exclude=.svn /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/Reduce.java src/org/spoofax/jsglr/client/Reduce.java
12d11
< 
25c24
<     public Reduce(int arity, int label, int status, boolean isRecoverAction) {
---
>     public Reduce(int arity, int label, int status, boolean isRecoverAction, boolean isCompletionAction) {
33c32
<         production = new Production(arity, label, status, isRecoverAction);
---
>         production = new Production(arity, label, status, isRecoverAction, isCompletionAction);
diff -r --exclude=.svn /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/ReduceLookahead.java src/org/spoofax/jsglr/client/ReduceLookahead.java
11d10
< 
34c33
<         production = new Production(arity, label, status, false);
---
>         production = new Production(arity, label, status, false, false);
diff -r --exclude=.svn /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/RegionRecovery.java src/org/spoofax/jsglr/client/RegionRecovery.java
76a77,80
>     public boolean selectErroneousFragment(int failureOffset, int failureLineIndex){
>     	return selectErroneousFragment(failureOffset, failureLineIndex, -1);
>     }
> 
79d82
<      * @throws InterruptedException 
81c84
<     public boolean selectErroneousFragment() throws InterruptedException { 
---
>     public boolean selectErroneousFragment(int failureOffset, int failureLineIndex, int cursorLineIndex) { 
85,88c88,91
<         int failureIndex=getHistory().getIndexLastLine();
<         assert(failureIndex >= 0);
<         errorDetectionLocation=getHistory().getIndexLastToken();
<         ArrayList<StructureSkipSuggestion> prevRegions=newRegionSelector.getPreviousSkipSuggestions(failureIndex);
---
>         errorDetectionLocation = failureOffset - 1;
>         assert(failureLineIndex >= 0);
>                 
>         ArrayList<StructureSkipSuggestion> prevRegions=newRegionSelector.getPreviousSkipSuggestions(failureLineIndex);
95c98
<         ArrayList<StructureSkipSuggestion> currentRegions=newRegionSelector.getCurrentSkipSuggestions(failureIndex);
---
>         ArrayList<StructureSkipSuggestion> currentRegions=newRegionSelector.getCurrentSkipSuggestions(failureLineIndex);
99a103,118
> 
>         if(0 <= cursorLineIndex && cursorLineIndex < failureLineIndex){
> 	        ArrayList<StructureSkipSuggestion> cursorRegions=newRegionSelector.getCurrentSkipSuggestions(cursorLineIndex);
> 	        //System.out.println("CURSOR REGION");
> 	        if(trySetErroneousRegion(cursorRegions)){
> 				//System.out.println("Region Selection on cursor line succeeded!");
> 	            return true;
> 	        }
> 	        //System.out.println("CURSOR PARENT REGION");
> 	        ArrayList<StructureSkipSuggestion> cursorParentRegion=newRegionSelector.getParentSkipSuggestions(cursorLineIndex);
> 	        if(trySetErroneousRegion(cursorParentRegion)){            
> 				//System.out.println("Region Selection on cursor line succeeded!");
> 	            return true;
> 	        }
>         }
> 
101c120
<         ArrayList<StructureSkipSuggestion> priorRegions=newRegionSelector.getPriorSkipSuggestions(failureIndex);
---
>         ArrayList<StructureSkipSuggestion> priorRegions=newRegionSelector.getPriorSkipSuggestions(failureLineIndex);
108c127
<         ArrayList<StructureSkipSuggestion> siblingForWardRegions=newRegionSelector.getSibblingForwardSuggestions(failureIndex);
---
>         ArrayList<StructureSkipSuggestion> siblingForWardRegions=newRegionSelector.getSibblingForwardSuggestions(failureLineIndex);
113c132
<         ArrayList<StructureSkipSuggestion> siblingBackWardRegions=newRegionSelector.getSibblingBackwardSuggestions(failureIndex);
---
>         ArrayList<StructureSkipSuggestion> siblingBackWardRegions=newRegionSelector.getSibblingBackwardSuggestions(failureLineIndex);
118c137
<         ArrayList<StructureSkipSuggestion> siblingSurroundingRegions=newRegionSelector.getSibblingSurroundingSuggestions(failureIndex);
---
>         ArrayList<StructureSkipSuggestion> siblingSurroundingRegions=newRegionSelector.getSibblingSurroundingSuggestions(failureLineIndex);
123c142
<         ArrayList<StructureSkipSuggestion> parentRegion=newRegionSelector.getParentSkipSuggestions(failureIndex);
---
>         ArrayList<StructureSkipSuggestion> parentRegion=newRegionSelector.getParentSkipSuggestions(failureLineIndex);
132c151
<         erroneousRegion=newRegionSelector.getErroneousPrefix(failureIndex);
---
>         erroneousRegion=newRegionSelector.getErroneousPrefix(failureLineIndex);
149,150c168,169
<             if(getHistory().getIndexLastLine()>=failureIndex+NR_OF_LINES_TILL_SUCCESS)
<                 indexAccept=failureIndex+NR_OF_LINES_TILL_SUCCESS;
---
>             if(getHistory().getIndexLastLine()>=failureLineIndex+NR_OF_LINES_TILL_SUCCESS)
>                 indexAccept=failureLineIndex+NR_OF_LINES_TILL_SUCCESS;
162c181
<     private boolean trySetErroneousRegion(ArrayList<StructureSkipSuggestion> regions) throws InterruptedException {
---
>     private boolean trySetErroneousRegion(ArrayList<StructureSkipSuggestion> regions) {
180c199
<     private boolean testRegion(StructureSkipSuggestion aSkip) throws InterruptedException {
---
>     private boolean testRegion(StructureSkipSuggestion aSkip) {
211c230
<             StructureSkipSuggestion aSkip) throws InterruptedException {
---
>             StructureSkipSuggestion aSkip) {
224,227d242
<     private String getInputFragment(StructureSkipSuggestion aSkip) {
<         return getHistory().getFragment(aSkip.getStartSkip().getTokensSeen(), aSkip.getEndSkip().getTokensSeen()-1, myParser.currentInputStream);
<     }
< 
diff -r --exclude=.svn /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/SGLR.java src/org/spoofax/jsglr/client/SGLR.java
18d17
< import org.spoofax.jsglr.client.indentation.LayoutFilter;
27,34c26,28
<   private static final boolean ENFORCE_NEWLINE_FITER = true;
<   private static final boolean PARSE_TIME_LAYOUT_FITER = true;
<   
<   private int layoutFiltering;
<   
<   private int enforcedNewlineSkip = 0;
<   
<   private RecoveryPerformance performanceMeasuring;
---
>     private static final int COMPLETION_REGION_SIZE = 1000;
> 
> 	private RecoveryPerformance performanceMeasuring;
40c34
< 	static final int TAB_SIZE = 8;
---
> 	static final int TAB_SIZE = 4;//8;
61,64c55,56
< 	
< 	private int currentIndentation;
< 	
< 	protected int tokensSeen;
---
> 
> 	private int tokensSeen;
70,74c62
<   protected int lastLineNumber;
< 
<   protected int lastColumnNumber;
< 
<   private int startOffset;
---
> 	private int startOffset;
111,112d98
< 	
< 	private AbstractParseNode parseTree;
114a101,112
> 
> 	public void setUseStructureRecovery(boolean useRecovery) {
> 		this.useIntegratedRecovery = useRecovery;
> 		this.recoverIntegrator = new RecoveryConnector(this);
> 	}
> 
> 	public void setUseStructureRecovery(boolean useRecovery, IntegratedRecoverySettings settings, FineGrainedSetting fgSettings) {
> 		this.useIntegratedRecovery = useRecovery;
> 		this.recoverIntegrator = new RecoveryConnector(this, settings, fgSettings);
> 	}
> 
> 	private boolean isCompletionMode;
118a117,120
> 	
> 	public int getParserLocation(){
> 		return this.getHistory().getTokenIndex(); //should also work in recover mode
> 	}
120c122,124
< 	private boolean fineGrainedOnRegion;
---
> 	private boolean isFineGrainedMode;
> 	
> 	private int fineGrainedStartLocation;
122c126,128
< 	private LayoutFilter layoutFilter;
---
> 	private int fineGrainedRecoverMax;
> 
> 	private int cursorLocation;
123a130,141
> 	public int getCursorLocation() {
> 		return cursorLocation;
> 	}
> 	
> 	public boolean isSetCursorLocation() {
> 		return 0 < cursorLocation && cursorLocation != Integer.MAX_VALUE;
> 	}
> 	
> 	private void setCompletionParse(boolean isCompletionMode, int cursorLocation){
> 		this.isCompletionMode = isCompletionMode;
> 		this.cursorLocation = cursorLocation;
> 	}
132,144c150
< 	
< 	public int getEnforcedNewlineSkips() {
< 	  return enforcedNewlineSkip;
< 	}
<    
< 	public int getLayoutFilteringCount() {
<     return layoutFiltering;
<   }
< 	
< 	 public int getLayoutFilterCallCount() {
< 	    return layoutFilter.getFilterCallCount();
< 	  }
< 	  
---
>     
174d179
< 
181c186
< 		recoverIntegrator = null;
---
> 		setUseStructureRecovery(false);
182a188
>     	setCompletionParse(false, Integer.MAX_VALUE);
184,199d189
< 		layoutFilter = new LayoutFilter(parseTable, true);
< 	}
< 
< 	public void setUseStructureRecovery(boolean useRecovery, IRecoveryParser parser) {
< 		useIntegratedRecovery = useRecovery;
< 		recoverIntegrator = new RecoveryConnector(this, parser);
< 	}
< 
< 	/**
< 	 * Enables error recovery based on region recovery and, if available, recovery rules.
< 	 * Does not enable bridge parsing.
< 	 *
< 	 * @see ParseTable#hasRecovers()   Determines if the parse table supports recovery rules
< 	 */
< 	public final void setUseStructureRecovery(boolean useRecovery) {
< 		setUseStructureRecovery(useRecovery, null);
202,203c192,193
<     protected void setFineGrainedOnRegion(boolean fineGrainedMode) {
<         fineGrainedOnRegion = fineGrainedMode;
---
>     protected void setFinegrainedRecoverMode(boolean fineGrainedMode) {
>         this.isFineGrainedMode = fineGrainedMode;
205a196,199
>     
>     protected void setFineGrainedStartLocation(int fineGrainedStartLocation) {
> 		this.fineGrainedStartLocation = fineGrainedStartLocation;
> 	}
207,220c201,203
<     @Deprecated
<     protected void setUseFineGrained(boolean useFG) {
<         recoverIntegrator.setUseFineGrained(useFG);
<     }
< 
<     // FIXME: we have way to many of these accessors; does this have to be public?
<     //        if not for normal use, it should at least be 'internalSet....'
<     @Deprecated
<     public void setCombinedRecovery(boolean useBP, boolean useFG,
<             boolean useOnlyFG) {
<         recoverIntegrator.setOnlyFineGrained(useOnlyFG);
<         recoverIntegrator.setUseBridgeParser(useBP);
<         recoverIntegrator.setUseFineGrained(useFG);
<     }
---
>     protected void setFineGrainedRecoverMax(int fineGrainedRecoverMax) {
> 		this.fineGrainedRecoverMax = fineGrainedRecoverMax;
> 	}
272c255
<     TokenExpectedException, ParseException, SGLRException, InterruptedException {
---
>     TokenExpectedException, ParseException, SGLRException {
278c261
<     TokenExpectedException, ParseException, SGLRException, InterruptedException {
---
>     TokenExpectedException, ParseException, SGLRException {
285a269,285
> 	 * @param input           The input string.
> 	 * @param filename        The source filename of the string, or null if not available.
> 	 * @param startSymbol     The start symbol to use, or null if any applicable.
> 	 * @param completionMode  True in case the parser result is used for content completion.
> 	 * @param cursorLocation  The location of the cursor used to find completion recoveries.
> 	 */
>     public Object parse(String input, String filename, String startSymbol, boolean completionMode, int cursorLocation) 
>     	throws BadTokenException, TokenExpectedException, ParseException, SGLRException {
>     	setCompletionParse(completionMode, cursorLocation);
>     	Object parseResult = parse(input, filename, startSymbol);
>     	setCompletionParse(false, Integer.MAX_VALUE);
>     	return parseResult;
>     }
> 
>     /**
> 	 * Parses a string and constructs a new tree using the tree builder.
> 	 * 
289d288
< 	 * @throws InterruptedException 
292c291
< 	SGLRException, InterruptedException {
---
> 	SGLRException {
296a296
> 		getPerformanceMeasuring().startParse();
303,304c303
< 	ParseException, SGLRException, InterruptedException {
< 		getPerformanceMeasuring().startParse();
---
> 	ParseException, SGLRException {
307,309d305
< 		     if (Thread.currentThread().isInterrupted())
< 		        throw new InterruptedException();
< 
311d306
< 				//System.out.print((char)currentToken);
314c309
< 			} while (currentToken != SGLR.EOF && activeStacks.size() > 0);
---
> 			} while (getCurrentToken() != SGLR.EOF && activeStacks.size() > 0);
328c323
< 			throw new ParseTimeoutException(this, currentToken, tokensSeen - 1, lineNumber,
---
> 			throw new ParseTimeoutException(this, getCurrentToken(), tokensSeen - 1, lineNumber,
344a340,343
> 		//System.out.println(s.recoverCount);
> 		assert(s.recoverCount <= s.recoverWeight);
> 
> 		performanceMeasuring.setRecoverCount(s.recoverCount);
347c346,347
< 		Tools.debug("avoids: ", s.recoverCount);
---
> 		//System.out.println("recoveries: " + s.recoverCount);
> 		Tools.debug("recoveries: ", s.recoverCount);
353d352
< 		  this.parseTree = s.label;
362,385d360
< 	
< 	protected void setCurrentToken(int tok) {
< 	  if (currentToken == -1)
< 	    currentIndentation = 0;
< 	  else
< 	    switch (currentToken) {
< 	    case '\n':
< 	      currentIndentation = 0;
< 	      break;
< 	    case '\t':
< 	      currentIndentation = (currentIndentation / TAB_SIZE + 1) * TAB_SIZE;
< 	      break;
< 	    case -1:
< 	      break;
< 	    default:
< 	      currentIndentation++;
< 	    }
< 	  
< 	  this.currentToken = tok;
< 	}
< 	
< 	protected int getCurrentToken() {
< 	  return this.currentToken;
< 	}
387c362
< 	protected void doParseStep() throws InterruptedException {
---
> 	protected void doParseStep() {
399,400d373
< 		currentToken = -1;
< 		currentIndentation = 0;
409c382
< 		pathCache.resetPerformanceCounters();
---
> 		PathListPool.resetPerformanceCounters();
411,413d383
< 		parseTree = null;
< 		enforcedNewlineSkip = 0;
< 		layoutFiltering = 0;
455c425
< 					return new TokenExpectedException(this, expected.toString(), currentToken,
---
> 					return new TokenExpectedException(this, expected.toString(), getCurrentToken(),
461c431
< 		return new BadTokenException(this, currentToken, tokensSeen + startOffset - 1, lineNumber,
---
> 		return new BadTokenException(this, getCurrentToken(), tokensSeen + startOffset - 1, lineNumber,
468c438
< 		final AbstractParseNode prod = new ParseProductionNode(currentToken, lastLineNumber, lastColumnNumber);
---
> 		final AbstractParseNode prod = parseTable.lookupProduction(getCurrentToken());
478c448
< 				st1.addLink(as.st, prod, 1, lastLineNumber, lastColumnNumber);
---
> 				st1.addLink(as.st, prod, 1);
496c466
< 	private void parseCharacter() throws InterruptedException {
---
> 	private void parseCharacter() {
506,508d475
< 		  if (Thread.currentThread().isInterrupted())
< 		    throw new InterruptedException();
< 		  
546c513
< 	private void actor(Frame st) throws InterruptedException {
---
> 	private void actor(Frame st) {
552c519
< 			if (action.accepts(currentToken)) {
---
> 			if (action.accepts(getCurrentToken())) {
558c525
< 						actState.currentToken = currentToken;
---
> 						actState.currentToken = getCurrentToken();
600c567
< 		return doCheckLookahead(red, red.getCharRanges());
---
> 		return doCheckLookahead(red, red.getCharRanges(), 0);
603c570
< 	private boolean doCheckLookahead(ReduceLookahead red, RangeList[] charClass) {
---
> 	private boolean doCheckLookahead(ReduceLookahead red, RangeList[] charClass, int pos) {
608,630c575,585
< 		if (charClass.length == 0)
< 		  return true;
< 		
<     boolean permit = false;
<     int offset = -1;
<     int[] readChars = new int[charClass.length];
< 		
<     int i;
< 		for (i = 0; i < charClass.length; i++) {
<   		int c = currentInputStream.read();
<   		offset++;
<   		readChars[offset] = c; 
<   
<   		// EOF
<   		if(c == -1) {
<   			permit = true;
<   			break;
<   		}
<   
<   		if (!charClass[i].within(c)) {
<   		  permit = true;
<   		  break;
<   		}
---
> 		final int c = currentInputStream.read();
> 
> 		// EOF
> 		if(c == -1) {
> 			return true;
> 		}
> 
> 		boolean permit = true;
> 
> 		if(pos < charClass.length) {
> 			permit = charClass[pos].within(c) ? false : doCheckLookahead(red, charClass, pos + 1);
633,634c588
< 		for (int j = offset; j >= 0; j--)
< 		  currentInputStream.unread(readChars[j]);
---
> 		currentInputStream.unread(c);
649c603
< 			maxToken = currentToken;
---
> 			maxToken = getCurrentToken();
657c611
< 	private void doReductions(Frame st, Production prod) throws InterruptedException {
---
> 	private void doReductions(Frame st, Production prod) {
659,661d612
< 	  if (Thread.currentThread().isInterrupted())
< 	    throw new InterruptedException();
< 	  
665,666c616,617
< 		
< 				PooledPathList paths = pathCache.create();
---
> 
> 		PooledPathList paths = pathCache.create();
678c629,638
< 		return !prod.isRecoverProduction() || fineGrainedOnRegion;
---
> 		if(!prod.isCompletionProduction()){
> 			return !prod.isRecoverProduction() || isFineGrainedMode;
> 		}
> 		return inCompletionMode(prod);
> 	}
> 
> 	private boolean inCompletionMode(Production prod) {
> 		if(!prod.isCompletionStartProduction()) //Performance trick: -> "@#$" {completion} starts the completion
> 			return isCompletionMode && cursorLocation <= getParserLocation() && getParserLocation() <= cursorLocation + COMPLETION_REGION_SIZE;
> 		return isCompletionMode && cursorLocation - COMPLETION_REGION_SIZE <= getParserLocation() && getParserLocation() <= cursorLocation;
681c641
< 	private void doLimitedReductions(Frame st, Production prod, Link l) throws InterruptedException { //Todo: Look add sharing code with doReductions
---
> 	private void doLimitedReductions(Frame st, Production prod, Link l) { //Todo: Look add sharing code with doReductions
695c655
< 	private void reduceAllPaths(Production prod, PooledPathList paths) throws InterruptedException {
---
> 	private void reduceAllPaths(Production prod, PooledPathList paths) {
703,738c663,670
< 			
< 			if (PARSE_TIME_LAYOUT_FITER &&
< 			    !layoutFilter.hasValidLayout(prod.label, kids)) {
< 			  layoutFiltering++;
< 			  continue;
< 			}
< 			else if (PARSE_TIME_LAYOUT_FITER)
< 			  layoutFiltering += layoutFilter.getDisambiguationCount();
< 			
< 			if (ENFORCE_NEWLINE_FITER && 
<           parseTable.getLabel(prod.label).getAttributes().isNewlineEnforced()) {
<         boolean hasNewline = false;
<         for (int j = kids.length - 1; j >= 0; j--) {
<           int status = kids[j].getLayoutStatus();
<           
<           if (status == AbstractParseNode.NEWLINE_LAYOUT) {
<             hasNewline = true;
<             break;
<           }
<           if (status == AbstractParseNode.OTHER_LAYOUT) {
<             hasNewline = false;
<             break;
<           }
<         }
<         
<         if (!hasNewline) {
<           enforcedNewlineSkip++;
<           continue;
<         }
<       }
< 
< 
< 			if(!prod.isRecoverProduction())
< 				reducer(st0, next, prod, kids, path);
< 			else
< 				reducerRecoverProduction(st0, next, prod, kids, path);				
---
> 			if(!prod.isCompletionProduction() || isReductionOverCursorLocation(path)){
> 				if(checkMaxRecoverCount(prod, path)){
> 					if(!prod.isRecoverProduction())
> 						reducer(st0, next, prod, kids, path);
> 					else
> 						reducerRecoverProduction(st0, next, prod, kids, path);
> 				}
> 			}
746a679,695
> 	private boolean checkMaxRecoverCount(Production prod, final Path path) {
> 		return checkRecoverCountLocal(prod, path) && checkRecoverCountGlobal(prod, path);
> 	}
> 
> 	private boolean checkRecoverCountLocal(Production prod, final Path path) {
> 		return !isFineGrainedMode || 
> 			calcRecoverCount(prod, path) <= fineGrainedRecoverMax || 
> 			getHistory().getTokenIndex() - path.getLength() < fineGrainedStartLocation; //large reduction
> 	}
> 
> 	private boolean checkRecoverCountGlobal(Production prod, final Path path) {
> 		return calcRecoverCount(prod, path) <= this.recoverIntegrator.getMaxNumberOfRecoverApplicationsGlobal();
> 	}
> 
> 	private boolean isReductionOverCursorLocation(final Path path) {
> 		return getParserLocation() - path.getLength() < cursorLocation;
> 	}
748c697
< 	private void reducer(Frame st0, State s, Production prod, AbstractParseNode[] kids, Path path) throws InterruptedException {
---
> 	private void reducer(Frame st0, State s, Production prod, AbstractParseNode[] kids, Path path) {
753d701
< //		final boolean illegalLayout = !layoutFilter.hasValidLayout(prod, kids, parseTable);
756,760c704,705
< 		final AbstractParseNode t = prod.apply(kids, 
< 		                                       path.getParentCount() > 0 ? path.getParent().getLink().getLine() : lineNumber, 
< 		                                       path.getParentCount() > 0 ? path.getParent().getLink().getColumn() : columnNumber,
< 		                                       parseTable.getLabel(prod.label).isLayout(),
< 		                                       parseTable.getLabel(prod.label).getAttributes().isIgnoreLayout());
---
> 		final int recoverWeight = calcRecoverWeight(prod, path);
> 		final AbstractParseNode t = prod.apply(kids);
765,768c710
< 			Link nl = addNewStack(st0, s, prod, length, numberOfRecoveries, t);
< //			if (illegalLayout) {
< //			  nl.reject();
< //			}
---
> 			addNewStack(st0, s, prod, length, numberOfRecoveries, recoverWeight, t);
774,802c716,744
<         logAmbiguity(st0, prod, st1, nl);
<         if (prod.isRejectProduction()) {
<           nl.reject();
<         } 
< //        else if (illegalLayout) {
< //          nl.reject();
< //        }
<         if(numberOfRecoveries == 0 && nl.recoverCount == 0 || nl.isRejected()) {
<           createAmbNode(t, nl);
<         } else if (numberOfRecoveries < nl.recoverCount) {
<           nl.label = t;
<           nl.recoverCount = numberOfRecoveries;
<           actorOnActiveStacksOverNewLink(nl);
<         } else if (numberOfRecoveries == nl.recoverCount) {
<           nl.label = t;
<         }
<       } else {
<         nl = st1.addLink(st0, t, length, t.getLine(), t.getColumn());
<         nl.recoverCount = numberOfRecoveries;
<         if (prod.isRejectProduction()) {
<           nl.reject();
<           increaseRejectCount();
<         }
< //        else if (illegalLayout) {
< //          nl.reject();
< //        }
<         logAddedLink(st0, st1, nl);
<         actorOnActiveStacksOverNewLink(nl);
<       }
---
> 				logAmbiguity(st0, prod, st1, nl);
> 				if (prod.isRejectProduction()) {
> 					nl.reject();
> 				} 
> 				if(recoverWeight == 0 && nl.recoverWeight == 0 || nl.isRejected()) {
> 					createAmbNode(t, nl);
> 				} else if (recoverWeight < nl.recoverWeight) {
> 					nl.label = t;
> 					nl.recoverCount = numberOfRecoveries;
> 					nl.recoverWeight = recoverWeight;
> 					actorOnActiveStacksOverNewLink(nl);
> 				} else if (recoverWeight == nl.recoverWeight) {
> 					nl.label = t;
> 				}
> 			} else {
> 				nl = st1.addLink(st0, t, length);
> 				nl.recoverWeight = recoverWeight;
> 				nl.recoverCount = numberOfRecoveries;
> 				if (prod.isRejectProduction()) {
> 					nl.reject();
> 					increaseRejectCount();
> 				}
> 				logAddedLink(st0, st1, nl);
> 				actorOnActiveStacksOverNewLink(nl);
> 			}
> 		}
> 		if(Tools.tracing) {
> 			TRACE_ActiveStacks();
> 			TRACE("SG_ - reducer done");
810c752,753
< 		final AbstractParseNode t = prod.apply(kids, lineNumber, columnNumber, parseTable.getLabel(prod.label).isLayout(), parseTable.getLabel(prod.label).getAttributes().isIgnoreLayout());
---
> 		final int recoverWeight = calcRecoverWeight(prod, path);
> 		final AbstractParseNode t = prod.apply(kids);
812c755
< 		if(stActive!=null){
---
> 		if(stActive != null){
819c762
< 		if(stRecover!=null){
---
> 		if(stRecover != null){
821c764
< 			if(nlRecover!=null){
---
> 			if(nlRecover != null){
824c767
< 			nlRecover = stRecover.addLink(st0, t, length, t.getLine(), t.getColumn());
---
> 			nlRecover = stRecover.addLink(st0, t, length);
825a769
> 			nlRecover.recoverWeight = recoverWeight;
828c772
< 		addNewRecoverStack(st0, s, prod, length, numberOfRecoveries, t);
---
> 		addNewRecoverStack(st0, s, prod, length, numberOfRecoveries, recoverWeight, t);
839,840c783,784
< 	private Link addNewStack(Frame st0, State s, Production prod, int length,
< 			int numberOfRecoveries, AbstractParseNode t) {
---
> 	private void addNewStack(Frame st0, State s, Production prod, int length,
> 			int numberOfRecoveries, int recoverWeight, AbstractParseNode t) {
843c787
< 		final Link nl = st1.addLink(st0, t, length, t.getLine(), t.getColumn());
---
> 		final Link nl = st1.addLink(st0, t, length);
845a790
> 		nl.recoverWeight = recoverWeight;
860,861d804
< 		
< 		return nl;
868,869c811,812
< 			int numberOfRecoveries, AbstractParseNode t) {
< 		if (!(fineGrainedOnRegion && !prod.isRejectProduction())) {
---
> 			int numberOfRecoveries, int recoverWeight, AbstractParseNode t) {
> 		if (!(isFineGrainedMode && !prod.isRejectProduction())) {
873c816
< 		final Link nl = st1.addLink(st0, t, length, t.getLine(), t.getColumn());
---
> 		final Link nl = st1.addLink(st0, t, length);
874a818
> 		nl.recoverWeight = recoverWeight;
878c822
< 	private void actorOnActiveStacksOverNewLink(Link nl) throws InterruptedException {
---
> 	private void actorOnActiveStacksOverNewLink(Link nl) {
895c839
< 				if (action.accepts(currentToken)) {
---
> 				if (action.accepts(getCurrentToken())) {
917c861,869
< 		if (prod.isRecoverProduction()){
---
> 		if (prod.isRecoverProduction() || prod.isCompletionProduction()){
> 			result += 1;
> 		}
> 		return result;
> 	}
> 
> 	private int calcRecoverWeight(Production prod, Path path) {
> 		int result = path.getRecoverWeight();
> 		if (prod.isRecoverProduction() || prod.isCompletionProduction()){
919c871
< 			if (path.getLength() > 0)
---
> 			if (path.getLength() > 0 && !prod.isCompletionProduction())
925,1052c877
< 	
< 	int count = 0;
< 	int count2 = 0;
< 	
< 	
< //	private class LongestMatchKey {
< //	  private AbstractParseNode n1, n2;
< //	  public LongestMatchKey(AbstractParseNode n1, AbstractParseNode n2) { this.n1 = n1; this.n2 = n2; }
< //	  @Override public int hashCode() { return (9 << n1.hashCode()) + n2.hashCode(); }
< //	  @Override public boolean equals(Object o) { 
< //	    return o instanceof LongestMatchKey && ((LongestMatchKey) o).n1 == n1 && ((LongestMatchKey) o).n2 == n2;
< //	  }
< //	}
< //	private Map<LongestMatchKey, Integer> longestMatchCache = new HashMap<LongestMatchKey, Integer>();
< //	
< //	@SuppressWarnings("null")
< //  private AbstractParseNode filterLongestMatch(AbstractParseNode t1, AbstractParseNode t2) {
< //	  if (t1.isParseRejectNode() || t2.isParseRejectNode())
< //	    return null;
< //	  
< //	  System.out.println(t1.toString());
< //	  System.out.println(t2.toString());
< //	  
< //	  Stack<AbstractParseNode[]> stack = new Stack<AbstractParseNode[]>();
< //	  stack.push(new AbstractParseNode[] {t1, t2});
< //
< //	  LinkedList<LongestMatchKey> done = new LinkedList<LongestMatchKey>();
< //	  
< //	  AbstractParseNode res = null;
< //	  
< //	  while (!stack.isEmpty()) {
< //	    AbstractParseNode[] ns = stack.pop();
< //	    AbstractParseNode n1 = ns[0];
< //	    AbstractParseNode n2 = ns[1];
< //	  
< //	    if (n1.equals(n2))
< //	      continue;
< //	    
< //	    LongestMatchKey key = new LongestMatchKey(n1, n2);
< //	    Integer prevRes = longestMatchCache.get(key);
< //	    if (prevRes != null) {
< //	      AbstractParseNode newres = prevRes == -1 ? null : (prevRes == 0 ? t1 : t2);
< //	      if (res != null && res != newres) {
< //	        res = null;
< //	        break;
< //	      }
< //	      if (newres == null)
< //	        continue;
< //	      
< //	      res = newres;
< //	      break;
< //	    }
< //	    
< //	    Label l1 = n1.isAmbNode() ? null : parseTable.getLabel(n1.getLabel());
< //	    Label l2 = n2.isAmbNode() ? null : parseTable.getLabel(n2.getLabel());
< //	    
< //      if (n1.isAmbNode() || n2.isAmbNode()) {
< //        AbstractParseNode[] n1Array = n1.isAmbNode() ? n1.getChildren() : new AbstractParseNode[] {n1};
< //        AbstractParseNode[] n2Array = n2.isAmbNode() ? n2.getChildren() : new AbstractParseNode[] {n2};
< //        
< //        for (int i = 0; i < n1Array.length; i++)
< //          for (int j = 0; j < n2Array.length; j++) {
< //            if (!n1Array[i].isParseRejectNode() && !n2Array[j].isParseRejectNode())
< //              stack.push(new AbstractParseNode[] {n1Array[i], n2Array[j]});
< //          }
< //        continue;
< //      }
< //
< //	    else if (l1 != null && l1.getAttributes().isLongestMatch() && 
< //	             (l2 == null || !l2.getAttributes().isLongestMatch())) {
< //	      if (res == t2) {
< //	        res = null;
< //	        break;
< //	      }
< //	      res = t1;
< //	      break;
< //	    }
< //
< //      else if (l2 != null && l2.getAttributes().isLongestMatch() &&
< //               (l1 == null || !l1.getAttributes().isLongestMatch())) {
< //        if (res == t1) {
< //          res = null;
< //          break;
< //        }
< //        res = t2;
< //        break;
< //      }
< //	    
< //      else if (n1.getLabel() != n2.getLabel())
< //        continue;
< //
< //      else if (l1 != null && l2 != null &&
< //          l1.equals(l2) && l1.getAttributes().isLongestMatch()) {
< //        int[] end1 = n1.getEnd();
< //        int[] end2 = n2.getEnd();
< //        if (end1[0] > end2[0] || end1[0] == end2[0] && end1[1] > end2[1]) {
< //          if (res == t2) {
< //            res = null;
< //            break;
< //          }
< //          res = t1;
< //          break;
< //        }
< //        else if (end2[0] > end1[0] || end2[0] == end1[0] && end2[1] > end1[1]) {
< //          if (res == t1) {
< //            res = null;
< //            break;
< //          }
< //          res = t2;
< //          break;
< //        }
< //      }
< //	    
< //      done.add(key);
< //
< //      for (int i = n1.getChildren().length - 1; i >= 0; i--)
< //        stack.push(new AbstractParseNode[] {n1.getChildren()[i], n2.getChildren()[i]});
< //	  }
< //	  
< //	  int val = res == t1 ? 0 : (res == t2 ? 1 : -1);
< //	  for (LongestMatchKey key : done)
< //	    longestMatchCache.put(key, val);
< //	  
< //	  return res;
< //	}
< 	
< 	
<   private boolean inReduceStacks(Queue<Frame> q, Frame frame) {
---
> 	private boolean inReduceStacks(Queue<Frame> q, Frame frame) {
1114d938
< 		
1127,1129d950
< 		
< 		lastLineNumber = lineNumber;
< 		lastColumnNumber = columnNumber;
1160c981
< 	  return ambiguityManager;
---
> 		return ambiguityManager;
1162c983
< 	
---
> 
1195c1016
< 		System.out.println("[" + traceCallCount + "] " + string + "\n");
---
> 		System.err.println("[" + traceCallCount + "] " + string);
1295c1116
< 			Tools.logger("Current token (#", tokensSeen, "): ", logCharify(currentToken));
---
> 			Tools.logger("Current token (#", tokensSeen, "): ", logCharify(getCurrentToken()));
1314c1135
< 					logCharify(currentToken), ", line ", lineNumber, ", column ", columnNumber);
---
> 					logCharify(getCurrentToken()), ", line ", lineNumber, ", column ", columnNumber);
1320c1141
< 			Tools.debug(" token   : " + currentToken);
---
> 			Tools.debug(" token   : " + getCurrentToken());
1362c1183
< 			actionItems = s.getActionItems(currentToken);
---
> 			actionItems = s.getActionItems(getCurrentToken());
1376c1197
< 			Tools.debug(" token   : ", currentToken);
---
> 			Tools.debug(" token   : ", getCurrentToken());
1441c1262
< 		Tools.debug(" token : ", currentToken);
---
> 		Tools.debug(" token : ", getCurrentToken());
1465c1286
< 			Tools.logger("Reducing; state ", s.stateNumber, ", token: ", logCharify(currentToken),
---
> 			Tools.logger("Reducing; state ", s.stateNumber, ", token: ", logCharify(getCurrentToken()),
1473c1294
< 			Tools.debug(" token      : ", logCharify(currentToken) + " (" + currentToken + ")");
---
> 			Tools.debug(" token      : ", logCharify(getCurrentToken()) + " (" + getCurrentToken() + ")");
1501,1503c1322,1332
<   public AbstractParseNode getParseTree() {
<     return parseTree;
<   }
---
> 	protected void setCurrentToken(int currentToken) {
> 		this.currentToken = currentToken;
> 		if(currentToken == -1)
> 			this.currentToken=SGLR.EOF;
> 	}
> 
> 	protected int getCurrentToken() {
> 		assert(currentToken >= 0);
> 		return currentToken;
> 	}
> 
diff -r --exclude=.svn /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/Shift.java src/org/spoofax/jsglr/client/Shift.java
11d10
< 
diff -r --exclude=.svn /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/StructureSkipSuggestion.java src/org/spoofax/jsglr/client/StructureSkipSuggestion.java
4d3
< 
Only in src/org/spoofax/jsglr/client: editregion
diff -r --exclude=.svn /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/imploder/AbstractTokenizer.java src/org/spoofax/jsglr/client/imploder/AbstractTokenizer.java
42a43,46
> 	
> 	public void setSyntaxCorrect(boolean isSyntaxCorrect)  {
> 		this.isSyntaxCorrect = isSyntaxCorrect;
> 	}
67c71
< 		if (label.isRecover() || label.isReject() || label.getDeprecationMessage() != null) {
---
> 		if (label.isRecover() || label.isReject() || label.getDeprecationMessage() != null || label.isCompletion()) {
77c81
< 			
---
> 			//TODO: refactor
83c87,89
< 				first = findRightMostLayoutToken(getTokenAfter(prevToken));
---
> 				first = getTokenAfter(prevToken);
> 				if (first != currentToken() && first.getKind() == TK_LAYOUT)
> 					first = findRightMostLayoutToken(first);
88c94
< 			if (first.getStartOffset() + 1 == last.getEndOffset()) {
---
> 			if (first.getStartOffset() - 1 == last.getEndOffset()) {
90c96,98
< 				first = findLeftMostLayoutToken(first);
---
> 				first = last = findLeftMostLayoutToken(first);//mark insertion errors at the end of previous token (before layout)
> 				if (first.getKind() == TK_LAYOUT)
> 					first = last = getTokenBefore(last);
93,95c101
< 			String tokenText = toString(first, last);
< 			if (tokenText.length() > 40)
< 				tokenText = tokenText.substring(0, 40) + "...";
---
> 			String tokenText = makeTokenText(first, last);
97c103,112
< 			if (label.isReject() || prodReader.isWaterConstructor(label.getConstructor())) {
---
> 			if (label.isCompletion()) {
> 				if(last.getKind() == IToken.TK_LAYOUT){
> 					last = findLeftMostLayoutToken(last);
> 					if (last.getKind() == TK_LAYOUT)
> 						last = getTokenBefore(last);
> 				}
> 				String completionText = makeTokenText(first, last);
> 				setErrorMessage(first, last, ERROR_INCOMPLETE_PREFIX
> 						+ ": '" + completionText + "'");
> 			} else if (label.isReject() || prodReader.isWaterConstructor(label.getConstructor())) {
117a133,139
> 	private String makeTokenText(IToken first, IToken last) {
> 		String tokenText = toString(first, last);
> 		if (tokenText.length() > 40)
> 			tokenText = tokenText.substring(0, 40) + "...";
> 		return tokenText;
> 	}
> 
diff -r --exclude=.svn /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/imploder/AutoConcatList.java src/org/spoofax/jsglr/client/imploder/AutoConcatList.java
62,70d61
< 	public boolean merges(E e) {
< 	  if (e instanceof AutoConcatList) {
< 	    String esort = ((AutoConcatList<E>) e).sort;
< 	    return esort == null || esort.equals(sort);
< 	  }
< 	  return false;
< 	}
< 	
< 	@SuppressWarnings("unchecked")
diff -r --exclude=.svn /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/imploder/IToken.java src/org/spoofax/jsglr/client/imploder/IToken.java
50c50
< 	/** Token kind for a meta-esape operator. */
---
> 	/** Token kind for a meta-escape operator. */
66a67,69
> 	/**
> 	 * Gets the end offset (inclusive).
> 	 */
diff -r --exclude=.svn /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/imploder/ITokenizer.java src/org/spoofax/jsglr/client/imploder/ITokenizer.java
25c25,28
< 	
---
> 
> 	public static final String ERROR_INCOMPLETE_PREFIX =
> 		"Syntax error, incomplete construct";
> 
31a35
> 
67a72,73
> 	 * Additionally, ensures that {@link #isSyntaxCorrect()} returns false.
> 	 * 
85a92,93
> 	
> 	void setSyntaxCorrect(boolean syntaxCorrect);
diff -r --exclude=.svn /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/imploder/ITreeFactory.java src/org/spoofax/jsglr/client/imploder/ITreeFactory.java
5a6,7
> import org.spoofax.interpreter.terms.IStrategoList;
> import org.spoofax.interpreter.terms.IStrategoTerm;
45a48,49
> 	TNode createSublist(IStrategoList list, IStrategoTerm firstChild, IStrategoTerm lastChild);
> 
diff -r --exclude=.svn /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/imploder/ImploderAttachment.java src/org/spoofax/jsglr/client/imploder/ImploderAttachment.java
26c26
< 		new TermAttachmentType<ImploderAttachment>(ImploderAttachment.class, "ImploderAttachment", 5) {
---
> 		new TermAttachmentType<ImploderAttachment>(ImploderAttachment.class, "ImploderAttachment", 6) {
31a32,36
> 				
> 				String sortType = attachment.getSort() == null ? "" : attachment.getSort() ;
> 				String fileName = left.getTokenizer().getFilename()  == null ? "" :left.getTokenizer().getFilename();
> 				
> 				
33c38
< 					f.makeString(left.getTokenizer().getFilename()),
---
> 					f.makeString(fileName),
37c42,43
< 					f.makeInt(right.getEndOffset())
---
> 					f.makeInt(right.getEndOffset()),
> 					f.makeString( sortType )
43,44c49,54
< 				return createCompactPositionAttachment(asJavaString(subterms[0]), asJavaInt(subterms[1]),
< 						asJavaInt(subterms[2]), asJavaInt(subterms[3]), asJavaInt(subterms[4]));
---
> 				String fileName =  asJavaString(subterms[0]).equals("") ? null :asJavaString(subterms[0]);
> 				String sortType =  asJavaString(subterms[0]).equals("") ? null :asJavaString(subterms[5]);
> 				
> 				return createCompactPositionAttachment(fileName, asJavaInt(subterms[1]),
> 						asJavaInt(subterms[2]), asJavaInt(subterms[3]), asJavaInt(subterms[4]) , sortType);
> 				
91,93c101
< 	 * 
< 	 * @throws UnsupportedOperationException
< 	 *             If the node is not a list.
---
> 	 * Same as {@link #getSort()} for non-list terms.
96c104
< 		throw new UnsupportedOperationException();
---
> 		return getSort();
194a203,204
> 	
> 	
196a207,212
> 		return createCompactPositionAttachment(filename, line, column, startOffset, endOffset, null);
> 	}
> 	
> 	
> 	public static ImploderAttachment createCompactPositionAttachment(
> 			String filename, int line, int column, int startOffset, int endOffset, String sortType) {
198c214
< 		NullTokenizer newTokenizer = new NullTokenizer(null, filename, token);
---
> 		NullTokenizer newTokenizer = new NullTokenizer(sortType, filename, token);
201a218
> 	
215c232
< 			return "(" + sort + ",\"" + getLeftToken().getTokenizer().toString(getLeftToken(), getRightToken()) + "\")";
---
> 			return "(" + getSort() + ",\"" + getLeftToken().getTokenizer().toString(getLeftToken(), getRightToken()) + "\")";
217c234
< 			return "(" + sort + ",null)";
---
> 			return "(" + getSort() + ",null)";
diff -r --exclude=.svn /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/imploder/LabelInfo.java src/org/spoofax/jsglr/client/imploder/LabelInfo.java
31,32d30
< 	
< 	private final boolean isFlatten;
47c45,47
< 	
---
> 
> 	private final boolean isCompletion;
> 
60,61c60
< 		isList = reader.isList(rhs, attrs);
< 		isFlatten = reader.isFlatten(rhs, attrs);
---
> 		isList = reader.isList(rhs);
69a69
> 		isCompletion = reader.isCompletionProduction(attrs, production.getSubtermCount());
73c73
< 		metaVarConstructor = reader.getMetaVarConstructor(rhs, attrs);
---
> 		metaVarConstructor = reader.getMetaVarConstructor(rhs);
111,115c111
< 
<   public boolean isFlatten() {
<     return isFlatten;
<   }
< 
---
> 	
139c135,139
< 	
---
> 
> 	public boolean isCompletion() {
> 		return isCompletion && !isLiteral; //exclude artificial completion start: -> "@#$"{completion}
> 	}
> 
diff -r --exclude=.svn /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/imploder/ListImploderAttachment.java src/org/spoofax/jsglr/client/imploder/ListImploderAttachment.java
3d2
< 
Only in src/org/spoofax/jsglr/client/imploder: MemoryRecordingTreeBuilder.java
diff -r --exclude=.svn /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/imploder/NullTokenizer.java src/org/spoofax/jsglr/client/imploder/NullTokenizer.java
68d67
< 		// Do nothing
72c71
< 		// Do nothing
---
> 		setSyntaxCorrect(false);
83c82,85
< 		// Do nothing
---
> 		
> 		if (label.isRecover() || label.isReject() || label.isCompletion()) {
> 			setSyntaxCorrect(false);
> 		}
diff -r --exclude=.svn /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/imploder/ProductionAttributeReader.java src/org/spoofax/jsglr/client/imploder/ProductionAttributeReader.java
151c151,155
< 	
---
> 
> 	public boolean isCompletionProduction(IStrategoAppl attrs, int subtermCount) {
> 		return getAttribute(attrs, "completion") != null && subtermCount > 0;
> 	}
> 
198c202
< 	public String getMetaVarConstructor(IStrategoAppl rhs, IStrategoAppl attrs) {
---
> 	public String getMetaVarConstructor(IStrategoAppl rhs) {
201c205
< 			return isList(rhs, attrs)
---
> 			return isList(rhs)
339c343
< 	public boolean isList(IStrategoAppl rhs, IStrategoAppl attrs) {
---
> 	public boolean isList(IStrategoAppl rhs) {
354,361c358
< 		if (isIterFun(fun) || seqFun == fun)
< 		  return true;
< 		
< 	  return isFlatten(rhs, attrs);
< 	}
< 	
< 	public boolean isFlatten(IStrategoAppl rhs, IStrategoAppl attrs) {
< 	  return getAttribute(attrs, "flatten") != null;
---
> 		return isIterFun(fun) || seqFun == fun;
diff -r --exclude=.svn /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/imploder/TermTreeFactory.java src/org/spoofax/jsglr/client/imploder/TermTreeFactory.java
15a16
> import static org.spoofax.terms.attachments.ParentAttachment.putParent;
30a32,33
> import org.spoofax.terms.StrategoListIterator;
> import org.spoofax.terms.StrategoSubList;
31a35
> import org.spoofax.terms.attachments.ParentAttachment;
55c59
< 		setEnableTokens(false);
---
> 		setEnableTokens(false); // (is set by TreeBuilder.initializeParseTable)
134a139,183
> 	public IStrategoTerm createSublist(IStrategoList list, IStrategoTerm firstChild, IStrategoTerm lastChild) {
> 		ArrayList<IStrategoTerm> children = new ArrayList<IStrategoTerm>();
> 		boolean isStartChildFound = false;
> 		int indexStart = -1;
> 		int indexEnd = -1;
> 
> 		int i = 0;
> 		for (IStrategoTerm child : StrategoListIterator.iterable(list)) {
> 			if (child == firstChild) {
> 				indexStart = i;
> 				isStartChildFound = true;
> 			}
> 			if (isStartChildFound) {
> 				children.add(child);
> 				if (child == lastChild) {
> 					indexEnd = i;
> 					break;
> 				}
> 			}
> 			i++;
> 		}
> 		assert(0 <= indexStart && indexStart <= indexEnd);
> 		IStrategoList wrapped = factory.makeList(children);
> 		StrategoSubList result = new StrategoSubList(list, wrapped, indexStart, indexEnd);
> 		
> 		/* XXX: support updateParents again??
> 		if (cloneFirst) result = result.cloneIgnoreTokens();
> 		list.overrideReferences(getLeftToken(list), getRightToken(list), children, result);
> 		setParent(result, list);
> 		*/
> 		putParent(result, ParentAttachment.get(list));
> 		
> 		if(ImploderAttachment.get(firstChild) != null && ImploderAttachment.get(lastChild) != null)
> 			putImploderAttachment(
> 				result, 
> 				true,
> 				getElementSort(list), 
> 				getLeftToken(firstChild), 
> 				getRightToken(lastChild)
> 			);
> 		return result;
> 	}
> 
> 	
> 	
diff -r --exclude=.svn /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/imploder/Token.java src/org/spoofax/jsglr/client/imploder/Token.java
16c16
< 	private static Map<String, Integer> asyncAllTokenKinds;
---
> 	private transient static Map<String, Integer> asyncAllTokenKinds;
18c18
< 	private ITokenizer tokenizer;
---
> 	private transient ITokenizer tokenizer;
diff -r --exclude=.svn /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/imploder/Tokenizer.java src/org/spoofax/jsglr/client/imploder/Tokenizer.java
82c82,84
< 		assert i == 0 || result.getIndex() == i;
---
> 		// Disabled: might fail for testing language token sequences
> 		//           (e.g., self-application.spt)
> 		// assert i == 0 || result.getIndex() == i;
212a215,216
> 		
> 		setSyntaxCorrect(false);
diff -r --exclude=.svn /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/imploder/TreeBuilder.java src/org/spoofax/jsglr/client/imploder/TreeBuilder.java
3d2
< 
10d8
< import java.util.LinkedList;
209,310c207,262
< 	 public Object buildTreeNode(ParseNode node) {
<     LabelInfo label = labels[node.getLabel() - labelStart];
<     IToken prevToken = tokenizer.currentToken();
<     int lastOffset = offset;
<     AbstractParseNode[] subnodes = node.getChildren();
<     boolean isList = label.isList();
<     boolean isLayout = label.isLayout();
<     boolean lexicalStart = false;
<     
<     if (!inLexicalContext && label.isNonContextFree())
<       inLexicalContext = lexicalStart = true;
<     
<     List<Object> children;
<     
<     if (isLayout) {
<       // structure of layout does not matter; can simply iterate over all production nodes
<       children = null;
<       
<       LinkedList<AbstractParseNode> nodes = new LinkedList<AbstractParseNode>();
<       nodes.push(node);
< 
<       while (!nodes.isEmpty()) {
<         AbstractParseNode current = nodes.pop();
<         
<         if (current.isParseProductionNode())
<           buildTreeProduction((ParseProductionNode) current);
<         
<         for (int i = current.getChildren().length - 1; i >= 0; i--)
<           nodes.push(current.getChildren()[i]);
<       }
<     }
<     else if (isList) {
<       children = inLexicalContext ? null : new AutoConcatList<Object>(label.getSort());
< 
<       LinkedList<AbstractParseNode> nodes = new LinkedList<AbstractParseNode>();
<       nodes.push(node);
< 
<       while (!nodes.isEmpty()) {
<         AbstractParseNode current = nodes.pop();
<         
<         LabelInfo currentLabel = current.isAmbNode() || current.isParseProductionNode() ? null : labels[current.getLabel() - labelStart];
<         
<         if (currentLabel != null && currentLabel.isList() && (label.getSort() == null ? currentLabel.getSort() == null : label.getSort().equals(currentLabel.getSort())))
<           for (int i = current.getChildren().length - 1; i >= 0; i--)
<             nodes.push(current.getChildren()[i]);
<         else {
<           Object child;
<           if (inLexicalContext && current.isParseProductionChain())
<             child = chainToTreeTopdown(current);
<           else
<             child = current.toTreeTopdown(this);
< 
<           // TODO: handle ambiguities in lexicals better (ignored now)
<           if (inLexicalContext)
<             child = null;
<           if (child != null)
<             children.add(child);
<         }
<       }
< 
<       if (!inLexicalContext && isList && children.isEmpty()) {
<         IToken token = tokenizer.makeToken(tokenizer.getStartOffset() - 1, IToken.TK_LAYOUT, true);
<         ((AutoConcatList) children).setEmptyListToken(token);
<       }
<     } 
<     else {
<       children = inLexicalContext ? null : new ArrayList<Object>(max(EXPECTED_NODE_CHILDREN, subnodes.length));
< 
<       // Recurse
<       for (AbstractParseNode subnode : subnodes) {
<         Object child;
<         if (inLexicalContext && subnode.isParseProductionChain()) {
<           child = chainToTreeTopdown(subnode);
<         } else {
<           child = subnode.toTreeTopdown(this);
<         }
<         // TODO: handle ambiguities in lexicals better (ignored now)
<         if (inLexicalContext)
<           child = null;
<         if (child != null)
<           children.add(tryBuildAutoConcatListNode(child));
<       }
<     }
< 
<     
<     Object result;
<     if (lexicalStart) {
<       result = tryCreateStringTerminal(label, lastOffset);
<       inLexicalContext = false;
<     } else if (isLayout) {
<       result = null;
<     } else if (inLexicalContext) {
<       tokenizer.tryMakeLayoutToken(offset - 1, lastOffset - 1, label);
<       result = null; // don't create nodes inside lexical context; just create one big token at the top
<     } else if (isList) {
<       result = children;
<     } else {
<       result = createNodeOrInjection(label, prevToken, children);
<     }
<     tokenizer.markPossibleSyntaxError(label, prevToken, offset - 1, prodReader);
<     return result;
<   }
---
> 	public Object buildTreeNode(ParseNode node) {
> 		LabelInfo label = labels[node.getLabel() - labelStart];
> 		IToken prevToken = tokenizer.currentToken();
> 		int lastOffset = offset;
> 		AbstractParseNode[] subnodes = node.getChildren();
> 		boolean isList = label.isList();
> 		boolean lexicalStart = false;
> 		
> 		if (!inLexicalContext && label.isNonContextFree())
> 			inLexicalContext = lexicalStart = true;
> 		
> 		List<Object> children = null;
> 		if (!inLexicalContext) {
> 			if (isList) {
> 				children = new AutoConcatList<Object>(label.getSort());
> 			} else {
> 				children = new ArrayList<Object>(max(EXPECTED_NODE_CHILDREN, subnodes.length));
> 			}
> 		}
> 
> 		// Recurse
> 		for (AbstractParseNode subnode : subnodes) {
> 			Object child;
> 			if (inLexicalContext && subnode.isParseProductionChain()) {
> 				child = chainToTreeTopdown(subnode);
> 			} else {
> 				// TODO: Optimize stack - inline toTreeTopdown case selection?
> 				child = subnode.toTreeTopdown(this);
> 			}
> 			// TODO: handle ambiguities in lexicals better (ignored now)
> 			if (inLexicalContext)
> 				child = null;
> 			if (child != null)
> 				children.add(isList ? child : tryBuildAutoConcatListNode(child));
> 		}
> 		
> 		if (!inLexicalContext && isList && children.isEmpty()) {
> 			IToken token = tokenizer.makeToken(tokenizer.getStartOffset() - 1, IToken.TK_LAYOUT, true);
> 			((AutoConcatList) children).setEmptyListToken(token);
> 		}
> 		
> 		Object result;
> 		if (lexicalStart) {
> 			result = tryCreateStringTerminal(label, lastOffset);
> 			inLexicalContext = false;
> 		} else if (inLexicalContext) {
> 			tokenizer.tryMakeLayoutToken(offset - 1, lastOffset - 1, label);
> 			result = null; // don't create nodes inside lexical context; just create one big token at the top
> 		} else if (isList) {
> 			result = children;
> 		} else {
> 			result = createNodeOrInjection(label, prevToken, children);
> 		}
> 		tokenizer.markPossibleSyntaxError(label, prevToken, offset - 1, prodReader);
> 		return result;
> 	}
338,348c290
< 			AbstractParseNode n = a.getChildren()[0];
< 			switch (n.getNodeType()) {
< 	    case AbstractParseNode.CYCLE :
< 	      return buildTreeCycle((CycleParseNode) n);
< 	    case AbstractParseNode.PARSE_PRODUCTION_NODE :
< 	      return buildTreeProduction((ParseProductionNode) n);
< 	    case AbstractParseNode.AMBIGUITY :
< 	      return buildTreeAmb((ParseNode) n);
< 	    default :
< 	      return buildTreeNode((ParseNode) n);
< 	    }
---
> 			return a.getChildren()[0].toTreeTopdown(this);
366,381c308
< 			Object subtree;
< 			switch (subnode.getNodeType()) {
<       case AbstractParseNode.CYCLE :
<         subtree = buildTreeCycle((CycleParseNode) subnode);
<         break;
<       case AbstractParseNode.PARSE_PRODUCTION_NODE :
<         subtree = buildTreeProduction((ParseProductionNode) subnode);
<         break;
<       case AbstractParseNode.AMBIGUITY :
<         subtree = buildTreeAmb((ParseNode) subnode);
<         break;
<       default :
<         subtree = buildTreeNode((ParseNode) subnode);
<       }
< 			Object child = tryBuildAutoConcatListNode(subtree);
< 			
---
> 			Object child = tryBuildAutoConcatListNode(subnode.toTreeTopdown(this));
diff -r --exclude=.svn /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/incremental/IncrementalSGLR.java src/org/spoofax/jsglr/client/incremental/IncrementalSGLR.java
89d88
< 	 * @throws InterruptedException 
93c92
< 			throws TokenExpectedException, BadTokenException, ParseException, SGLRException, IncrementalSGLRException, InterruptedException {
---
> 			throws TokenExpectedException, BadTokenException, ParseException, SGLRException, IncrementalSGLRException {
diff -r --exclude=.svn /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client/incremental/IncrementalSortSet.java src/org/spoofax/jsglr/client/incremental/IncrementalSortSet.java
12a13
> import java.util.Collections;
46c47,51
< 
---
> 	
> 	public Set<String> getIncrementalSorts() {
> 		return Collections.unmodifiableSet(incrementalSorts);
> 	}
> 	
52c57
< 	private IncrementalSortSet(ParseTable table, boolean expand, Set<String> sorts) {
---
> 	private IncrementalSortSet(ParseTable table, boolean expand, boolean expandReverse, Set<String> sorts) {
57c62
< 		incrementalContainerSorts = getInjectionsTo(table, incrementalSorts, true);
---
> 		incrementalContainerSorts = expandReverse ? getInjectionsTo(table, incrementalSorts, true) : incrementalSorts;
61c66
< 		return new IncrementalSortSet(table, expand, asSet(sorts));
---
> 		return new IncrementalSortSet(table, expand, true, asSet(sorts));
65c70
< 		return new IncrementalSortSet(table, expand, sorts);
---
> 		return new IncrementalSortSet(table, expand, true, sorts);
67c72,80
< 	
---
> 
> 	public static IncrementalSortSet create(ParseTable table, boolean expand, boolean expandReverse, String... sorts) {
> 		return new IncrementalSortSet(table, expand, expandReverse, asSet(sorts));
> 	}
> 
> 	public static IncrementalSortSet create(ParseTable table, boolean expand, boolean expandReverse, Set<String> sorts) {
> 		return new IncrementalSortSet(table, expand, expandReverse, sorts);
> 	}
> 
Only in /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client: indentation
Only in /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/client: layoutrule
diff -r --exclude=.svn /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/io/SGLR.java src/org/spoofax/jsglr/io/SGLR.java
82d81
< 	 * @throws InterruptedException 
87c86
< 			SGLRException, SGLRException, IOException, InterruptedException {
---
> 			SGLRException, SGLRException, IOException {
92d90
< 	 * @throws InterruptedException 
97c95
< 			SGLRException, SGLRException, IOException, InterruptedException {
---
> 			SGLRException, SGLRException, IOException {
102d99
< 	 * @throws InterruptedException 
107c104
< 			SGLRException, IOException, InterruptedException {
---
> 			SGLRException, IOException {
113c110
< 			SGLRException, IOException, InterruptedException {
---
> 			SGLRException, IOException {
119c116
< 			SGLRException, SGLRException, IOException, InterruptedException {
---
> 			SGLRException, SGLRException, IOException {
125c122
< 			SGLRException, IOException, InterruptedException {
---
> 			SGLRException, IOException {
129d125
< 
Only in /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/shared: BadIndentationException.java
diff -r --exclude=.svn /Users/seba/projects/layout-parsing/jsglr-layout/src/org/spoofax/jsglr/shared/BadTokenException.java src/org/spoofax/jsglr/shared/BadTokenException.java
39c39
<         return getShortMessage() + " at line " + (lineNumber + 1)  + ", column " + (columnNumber - 1);
---
>         return getShortMessage() + " at line " + lineNumber + ", column " + columnNumber;
50c50
<     protected String escape(int ch) {
---
>     private String escape(int ch) {
