λ.
 «
  ? ≔ ♨ condition then else. org.spoofax.jsglr.tests.unicode.interpreter.Primitives#if_impl
  ⋀ ≔ ♨ φ ψ. org.spoofax.jsglr.tests.unicode.interpreter.Primitives#and_impl
  = ≔ ♨ α β. org.spoofax.jsglr.tests.unicode.interpreter.Primitives#equal_impl
  ≣ ≔ ♨ α β. org.spoofax.jsglr.tests.unicode.interpreter.Primitives#ident_impl
  ∎ ≔ ♨. org.spoofax.jsglr.tests.unicode.interpreter.Primitives#null_impl
  × ≔ ♨ α β. org.spoofax.jsglr.tests.unicode.interpreter.Primitives#times_impl
  + ≔ ♨ α β. org.spoofax.jsglr.tests.unicode.interpreter.Primitives#add_impl
  - ≔ ♨ α. org.spoofax.jsglr.tests.unicode.interpreter.Primitives#negate_impl
  ✎ Returns a new unique value, thus Ů is not functional!
  Ů ≔ ♨. org.spoofax.jsglr.tests.unicode.interpreter.Primitives#unique_impl
  ✎ Evaluates π, prints the result and evaluates itself to the result
  ✑ ≔ ♨ π. org.spoofax.jsglr.tests.unicode.interpreter.Primitives#print_impl
 »
  «
     false ≔ 0
     true ≔ 1
	 
	 − ≔ λ α β.
	 	 + (α -(β))
		
	 ✎ Empty Set:: List [Unique]		
     ∅ ≔ Ů ()
	 
	 ✎ Cons:: a List ↦ List [(Bool ↦ a | List)]
     ☐ ≔ 	λ α β. λ σ. 
     			? (σ β α)
	 ✎ Head 
     ∫ ≔ λ σ. σ (false)
	 ✎ Tail
     ∬ ≔ λ σ. σ (true)

	 ✎ Is Empty
     ∅? ≔ 	λ σ.
     		= (σ ∅)
	
	 ✎ Map
     ∀ ≔ λ Φ. λ σ.
     		«∀i ≔ λ σ.
     			? (∅? (σ)
				∅
   				☐( Φ(∫(σ))
   					∀i (∬(σ))))
   			» ∀i (σ)
	 ✎ Fold
	 ⋐ ≔ λ Φ a σ.
				? (∅? (σ)
				a
				Φ (∫(σ) ⋐(Φ a ∬(σ))))
				
	 nth ≔ λ s. λ n.
	 		«i ≔ λ s n.
	 			? (≣(n 0) ∫(s) i(∬(s) -(n 1)))
			» i (s n)
			
  »
   «
    list ≔ ☐(1 ☐(2 ☐(3 ☐(4 ∅))))
	getter ≔ nth (⟨∀ (λ α. ×(α α))⟩ (list))
   »
   ✎ getter(n)
   ✎ = (∅ ∅)
   ✎ ⟨∀ (✑)⟩ (list)
   ✎ ⟨∀ (λ φ. ✑(getter(-(✑(φ) 1))))⟩ (list)
   ✑ (⋐(λ a b. + (a b) 0 list))
