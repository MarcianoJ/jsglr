module UnicodeLambdaLanguage

exports

	lexical syntax
		[\23-\3] -> X

	context-free start-symbols
		Lambda

	syntax
	%% Unicode([\u99776]) LAYOUT? <Id*-CF> LAYOUT? "." LAYOUT? <Exp-CF>	-> <Lambda-CF> {cons("Lambda")}

	context-free syntax
	
		Id AssignSign Exp		-> Declaration {cons("Declaration")}
	
		
		
		LetDeclaration Exp 	-> Exp {cons ("Let")}
		Lambda				-> Exp
		Integer				-> Exp 
		Identifier			-> Exp 
		LambdaApp			-> Exp
		JavaCall			-> Exp
		Identifier "(" Exp* ")" -> LambdaApp {cons("LambdaApp")}
		OpenLambdaBracket Exp CloseLambdaBracket "(" Exp* ")" -> LambdaApp {cons("ExpLambdaApp")}
		
		JavaCallSign JavaName	"(" Exp* ")" -> JavaCall {cons("JavaExpCall")}
		JavaCallSign Id* "." JavaName -> Lambda {cons("JavaLambda")}
		
		OpenLetBracket Declaration* CloseLetBracket -> LetDeclaration {cons("LetDeclaration")}
	
		Id -> Identifier {cons ("Identifier")}
		Int -> Integer{cons ("Integer")}
	
	context-free priorities
		
		
	lexical syntax
  		$Unicode([✎])	 ~[\n]* [\n] -> LAYOUT
		[\ \t\r\n] 						-> LAYOUT
		
	%%	(~[\ \t\r\n\.\(\)] / [0-9])+	-> Id {longest-match}
		((~[\ \t\r\n\.\(\)] / [0-9] / [\7]) | ($Unicode([ALL]/[⟨⟩])))+-> Id {longest-match}
		[0-9]+							-> Int {longest-match}
		[a-zA-Z]([a-zA-Z\.\$\#\_])*			-> JavaName {longest-match}
		
		$Unicode([λ])						-> LambdaSign
		$Unicode([λ])						-> Identifier {reject}
		$Unicode([≔])						-> AssignSign
		$Unicode([≔])						-> Identifier {reject}
		$Unicode([«])						-> OpenLetBracket
		$Unicode([»])						-> CloseLetBracket
		$Unicode([«])						-> Identifier {reject}
		$Unicode([»])						-> Identifier {reject}
		$Unicode([♨])						-> JavaCallSign
		$Unicode([♨])						-> Identifier {reject}
		$Unicode([⟨])						-> OpenLambdaBracket
		$Unicode([⟩])						-> CloseLambdaBracket
	