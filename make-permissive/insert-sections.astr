module insert-sections

imports
  sdf-injections

attributes

  def insert-sections:
    id ->
    |[ sorts
         WATEREOF
  
       lexical restrictions    
         WATEREOF -/- ~[]
         
       lexical syntax
         p*
    ]|
    with
      p* := id.all-insert-prods
  
  def at-root all-insert-prods =
    collect-all(
      id.insert-prod
    , id.union
    );
    flatten-list
    
  
attributes // Simple closing literals (e.g., "}")

  def insert-prod:
    prod([lit(_) | pattern], _, _) ->
    |[ 
       -> ~closinglit {avoid, cons("INSERTION")}
    ]|
    where
      id.in-context-free-section
    where
      closinglit := <last> pattern;
      ?lit(_)
    where
      not(closinglit.is-used-as-opening-literal)
  
  def Test is-used-as-opening-literal:
    lit(x) -> id
    where
      id.root;
      oncetd(
        id.eq(|lit(x));
        id.is-list-head
      )
  
  def Test is-list-head:
    [x | _] -> id
    where
      not(id.parent => [_ | _])

attributes // Comment closing literals

  def insert-prod:
    prod([openinglit | pattern-and-lit], sort, _) ->
    |[ 
       ~openinglit                    -> ~openingsort {avoid}
       ~openingsort ~pattern WATEREOF -> ~sort {cons("INSERTEND", avoid)}
    ]|
    where
      id.is-comment-prod
    with
      (pattern, closinglit) := <split-last> pattern-and-lit;
      openingsort           := <newname> "INSERTSTART"

  def Test is-comment-prod:
    prod([lit(_) | pattern-and-lit], target, _) -> id
    where
      closinglit := <last> pattern-and-lit;
      ?lit(_)
    where
      layout().eq(|target)
    <+
      target.direct-container-prods;
      one(
        // TODO: Use "is-injection-from"
        ?prod(_, layout(), _)
      )
  
attributes // String closing literals

  // TODO
