module insert-sections

imports
  sdf-injections

attributes

  def insert-sections:
    sections ->
    |[ sorts
         WATEREOF
  
       lexical restrictions    
         WATEREOF -/- ~[]
         
       lexical syntax
         p1*
       
       syntax
         p2*
    ]|
    with
      p1* := sections.all-lexical-insert-prods;
      p2* := sections.all-kernel-insert-prods
  
  def at-root all-lexical-insert-prods =
    collect-all(
      id.lexical-insert-prod
    , id.union
    );
    flatten-list
  
  def at-root all-kernel-insert-prods =
    collect-all(
      id.kernel-insert-prod
    , id.union
    );
    flatten-list
  
  def lexical-insert-prod
  
  def kernel-insert-prod
  
attributes // Simple closing literals (e.g., "}")

  eq lexical-insert-prod:
    prod([lit(_) | pattern], _, _) ->
    |[ 
       -> ~closinglit {avoid, cons("INSERTION")}
    ]|
    where
      id.in-context-free-section
    where
      closinglit := <last> pattern;
      ?lit(_)
    where
      not(closinglit.is-used-as-opening-literal)
  
  def Test is-used-as-opening-literal:
    lit(x) -> id
    where
      id.root;
      oncetd(
        id.eq(|lit(x));
        id.is-list-head
      )
  
  def Test is-list-head:
    [x | _] -> id
    where
      not(id.parent => [_ | _])

attributes // Comment closing literals

  // TODO: INSERTSTART*, INSERTOPENQUOTE sorts should be declared

  eq lexical-insert-prod:
    prod([openinglit | pattern-and-lit], sort, _) ->
    |[ 
       ~openinglit                    -> ~openingsort {avoid}
       ~openingsort ~pattern WATEREOF -> ~sort {cons("INSERTEND", avoid)}
    ]|
    where
      id.is-comment-prod
    where
      (pattern, closinglit) := <split-last> pattern-and-lit
    with
      openingsort := <newname> "INSERTSTART"

  def Test is-comment-prod:
    prod([lit(_) | pattern-and-lit], target, _) -> id
    where
      closinglit := <last> pattern-and-lit;
      ?lit(_)
    where
      layout().eq(|target)
    <+
      target.direct-container-prods;
      one(
        // TODO: Use "is-injection-from"
        ?prod(_, layout(), _)
      )
  
attributes // String closing literals

  eq lexical-insert-prod =
    id.in-lexical-section;
    id.insert-quote-prod
  
  eq kernel-insert-prod =
    id.in-kernel-section;
    id.insert-quote-prod

  def insert-quote-prod:
    prod([openingquote | pattern-and-quote], sort, _) ->
    |[ 
       ~openingquote                  -> INSERTOPENQUOTE {avoid}
       INSERTOPENQUOTE ~pattern "\\n" -> ~sort {cons("INSERTEND"), avoid}
    ]|
    where
      (pattern, closingquote) := <split-last> pattern-and-quote
    where
      openingquote.eq(|closingquote);
      openingquote.is-quote-lit
      
  def id.pattern-allows-newlines =
    fail // TODO: Check if string pattern does not allow newlines?
  
  def Test is-quote-lit:
    lit(quote) -> id
    where
      id.root;
      alltd(
        id.eq(|lit(quote));
        id.in-potential-quote-prod
      )

  def Test down in-potential-quote-prod:
    prod([openingquote | pattern-and-quote], _, _) -> id
    where
      id.in-lexical-section + id.in-kernel-section
    where
      (pattern, closingquote) := <split-last> pattern-and-quote
    where
      openingquote.eq(|closingquote)
    where
      not(pattern.pattern-allows-newlines)

